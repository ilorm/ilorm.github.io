{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ilorm index \u00b6 Welcome to the ilorm documentation! Quick start guide . Ilorm is a javascript ORM build with modern technologies. Come here to discover the Ilorm API . Why a new ORM ? \u00b6 Use newest feature of ECMAScript (modern javascript). Universal database connector (MongoDB, SQL, Redis, REST, CSV...). Could create powerful plugin using the \"class\" inheritance. Features \u00b6 Universal connector to bind every kind of database Powerful plugin ecosystem Query builder Data validation Start with ilorm \u00b6 API Advanced subject \u00b6 Create a connector Resources \u00b6 Connectors \u00b6 Knex connector (Support MySQL, PostgreSQL, Oracle, Redshift, MariaDB, SQLite ...). MongoDB connector Plugins \u00b6 Work in progress","title":"Home"},{"location":"#ilorm-index","text":"Welcome to the ilorm documentation! Quick start guide . Ilorm is a javascript ORM build with modern technologies. Come here to discover the Ilorm API .","title":"Ilorm index"},{"location":"#why-a-new-orm","text":"Use newest feature of ECMAScript (modern javascript). Universal database connector (MongoDB, SQL, Redis, REST, CSV...). Could create powerful plugin using the \"class\" inheritance.","title":"Why a new ORM ?"},{"location":"#features","text":"Universal connector to bind every kind of database Powerful plugin ecosystem Query builder Data validation","title":"Features"},{"location":"#start-with-ilorm","text":"API","title":"Start with ilorm"},{"location":"#advanced-subject","text":"Create a connector","title":"Advanced subject"},{"location":"#resources","text":"","title":"Resources"},{"location":"#connectors","text":"Knex connector (Support MySQL, PostgreSQL, Oracle, Redshift, MariaDB, SQLite ...). MongoDB connector","title":"Connectors"},{"location":"#plugins","text":"Work in progress","title":"Plugins"},{"location":"quick_start/","text":"Quick start \u00b6 Ilorm are based on five core concepts : Connector, Model, Schema, SchemaField and Query. - Connectors are the definition which kind of database you use to store your data. - Model are class representing your data. - Schema define your model behavior (fields type) - SchemaField define the behavior of your data field. - Query is a powerful query builder tool to edit, delete, get data... Install ilorm \u00b6 First install ilorm : npm install ilorm After you can install the mongo-connector : npm install ilorm-connector-mongodb You can use another connector if you use different kind of database. Define a schema \u00b6 To define your schema, just use the Schema class of ilorm const { Schema , } = require ( 'ilorm' ); const invoiceSchema = new Schema ({ createdAt : Schema . date (), amount : Schema . number () }); With this code, you have a basic schema with two properties : - createdAt which will be a date. - amount which will be a number. Prepare your Connector \u00b6 const MongoClient = require ( 'mongodb' ); const ilorm = require ( 'ilorm' ); const IlormMongo = require ( 'ilorm-connector-mongodb' ); // Declare you use ilormMongo (init plugin part of the connector) : ilorm . use ( IlormMongo ); // Create a database : const mongoClient = await MongoClient . connect ( DB_URL ); const database = await mongoClient . db ( 'ilorm' ); // Create your Connector class binded with your database : const MongoConnector = IlormMongo . fromClient ( database ); // Create an instance of your connector. It will save in the collection: accounts ; const invoiceConnector = new MongoConnector ({ collection : 'invoices' }); Now you have an invoiceConnector, it will save the binded model in the collection invoices . Create your model \u00b6 const { newModel , } = require ( 'ilorm' ); const modelConfig = { name : 'invoices' , // Optional, could be useful to know the model name schema : invoiceSchema , connector : invoiceConnector , } const Invoice = newModel ( modelConfig ); // Invoice Model is a class Now you have all you want : A model, you can manipulate your data Manipulate account \u00b6 Find one invoice after first january 2017 const invoice = await Invoice . query () . createdAt . greatherThan ( new Date ( '2017-01-01' )) . findOne (); Create a new invoice With attribute : const invoice = new Invoice (); invoice . createdAt = Date . now (); invoice . amount = 300 ; invoice . save (); Using constructor : const invoice = new Invoice ({ createdAt : Date . now (), amount : 300 , }); invoice . save (); Load an invoice per _id & remove it from database const invoice = await Invoice . getById ( ObjectId ( '2088181818' )); invoice . remove (); Full example \u00b6 const MongoClient = require ( 'mongodb' ); const ilorm = require ( 'ilorm' ); const IlormMongo = require ( 'ilorm-connector-mongodb' ); const { Schema , newModel , } = ilorm ; // Declare schema : const invoiceSchema = new Schema ({ createdAt : Schema . date (), amount : Schema . number () }); // Declare you use ilormMongo (init plugin part of the connector) : ilorm . use ( IlormMongo ); // Create a database : const mongoClient = await MongoClient . connect ( DB_URL ); const database = await mongoClient . db ( 'ilorm' ); // Create your Connector class binded with your database : const MongoConnector = IlormMongo . fromClient ( database ); // Create an instance of your connector. It will save in the collection: accounts ; const invoiceConnector = new MongoConnector ({ collection : 'invoices' }); const modelConfig = { name : 'invoices' , // Optional, could be useful to know the model name schema : invoiceSchema , connector : invoiceConnector , } const Invoice = newModel ( modelConfig ); // Invoice Model is a class","title":"Quick start"},{"location":"quick_start/#quick-start","text":"Ilorm are based on five core concepts : Connector, Model, Schema, SchemaField and Query. - Connectors are the definition which kind of database you use to store your data. - Model are class representing your data. - Schema define your model behavior (fields type) - SchemaField define the behavior of your data field. - Query is a powerful query builder tool to edit, delete, get data...","title":"Quick start"},{"location":"quick_start/#install-ilorm","text":"First install ilorm : npm install ilorm After you can install the mongo-connector : npm install ilorm-connector-mongodb You can use another connector if you use different kind of database.","title":"Install ilorm"},{"location":"quick_start/#define-a-schema","text":"To define your schema, just use the Schema class of ilorm const { Schema , } = require ( 'ilorm' ); const invoiceSchema = new Schema ({ createdAt : Schema . date (), amount : Schema . number () }); With this code, you have a basic schema with two properties : - createdAt which will be a date. - amount which will be a number.","title":"Define a schema"},{"location":"quick_start/#prepare-your-connector","text":"const MongoClient = require ( 'mongodb' ); const ilorm = require ( 'ilorm' ); const IlormMongo = require ( 'ilorm-connector-mongodb' ); // Declare you use ilormMongo (init plugin part of the connector) : ilorm . use ( IlormMongo ); // Create a database : const mongoClient = await MongoClient . connect ( DB_URL ); const database = await mongoClient . db ( 'ilorm' ); // Create your Connector class binded with your database : const MongoConnector = IlormMongo . fromClient ( database ); // Create an instance of your connector. It will save in the collection: accounts ; const invoiceConnector = new MongoConnector ({ collection : 'invoices' }); Now you have an invoiceConnector, it will save the binded model in the collection invoices .","title":"Prepare your Connector"},{"location":"quick_start/#create-your-model","text":"const { newModel , } = require ( 'ilorm' ); const modelConfig = { name : 'invoices' , // Optional, could be useful to know the model name schema : invoiceSchema , connector : invoiceConnector , } const Invoice = newModel ( modelConfig ); // Invoice Model is a class Now you have all you want : A model, you can manipulate your data","title":"Create your model"},{"location":"quick_start/#manipulate-account","text":"Find one invoice after first january 2017 const invoice = await Invoice . query () . createdAt . greatherThan ( new Date ( '2017-01-01' )) . findOne (); Create a new invoice With attribute : const invoice = new Invoice (); invoice . createdAt = Date . now (); invoice . amount = 300 ; invoice . save (); Using constructor : const invoice = new Invoice ({ createdAt : Date . now (), amount : 300 , }); invoice . save (); Load an invoice per _id & remove it from database const invoice = await Invoice . getById ( ObjectId ( '2088181818' )); invoice . remove ();","title":"Manipulate account"},{"location":"quick_start/#full-example","text":"const MongoClient = require ( 'mongodb' ); const ilorm = require ( 'ilorm' ); const IlormMongo = require ( 'ilorm-connector-mongodb' ); const { Schema , newModel , } = ilorm ; // Declare schema : const invoiceSchema = new Schema ({ createdAt : Schema . date (), amount : Schema . number () }); // Declare you use ilormMongo (init plugin part of the connector) : ilorm . use ( IlormMongo ); // Create a database : const mongoClient = await MongoClient . connect ( DB_URL ); const database = await mongoClient . db ( 'ilorm' ); // Create your Connector class binded with your database : const MongoConnector = IlormMongo . fromClient ( database ); // Create an instance of your connector. It will save in the collection: accounts ; const invoiceConnector = new MongoConnector ({ collection : 'invoices' }); const modelConfig = { name : 'invoices' , // Optional, could be useful to know the model name schema : invoiceSchema , connector : invoiceConnector , } const Invoice = newModel ( modelConfig ); // Invoice Model is a class","title":"Full example"},{"location":"advanced/create_connector/","text":"Create a connector \u00b6 The connector class \u00b6 Basics \u00b6 To create a connector, you need to implement a class Connector. The class Connector is always linked with a database The instance of the class is linked with a table, a collection or a subset of data. Example : On a SQL database The class is linked with the full database An instance of the class is linked with a table On a MongoDB database The class linked with the full database An instance of the class is linked with a collection Mandatory operation \u00b6 The class need to implement mandatory operation to be fully functional. The operations are divided into : Database related : Update, Find, Create, Remove data Connector factory : The connector instantiate his own Query class or Model class to overwrite basic behavior. Database related \u00b6 Ilorm query \u00b6 The majority of database related operation receive a Query instance as parameter. You need to use this query instance to create the same query in the database language to do it. The query have some useful method : queryBuilder and updateBuilder. queryBuilder \u00b6 query.queryBuilder is use to restrict your query. You will put as parameter of queryBuilder a set of handler. Each handler should be called back (in function of the query). query . queryBuilder ({ // On option will be called if skip & limit was put : onOption : ( skip , limit ) => {}, // If an or operator is used on the query, this handler will be called // The parameter is multiple query instance (each or branch) onOr : arrayOfQuery => {}, // If one or more field are select, this handler will be called // You need to restrict result only to the specified field onSelect : ({ field , }) => {}, // Called (in order), to set the order of the result. // Key is the target sorting key // behavior precise if it's ascending or descending sorting onSort : ({ key , behavior , }) => {}, // Called per each query operation // Key is the target key // Operation is EQUAL, NOT_EQUAL... // Value is the value applied to the operation onOperator : ({ key , operation , value , }) => {} }); Behavior and operation are equal to specific constants. The constants can be found in ilorm-constants in the QUERY constants : const { QUERY , } = require ( 'ilorm-constants' ); // Possible value of operation on the onOperator handler : const { OPERATIONS } = QUERY ; OPERATION . IS // equal (===) OPERATION . IS_NOT // Not equal (!==) OPERATION . IS_IN // The value is in the specified array of possibility OPERATION . IS_NOT_IN // The value is not in the specified array of possibility OPERATION . GREATHER_THAN // Superior of the value OPERATION . LOWER_THAN // Inferior of the value OPERATION_GREATHER_OR_EQUAL_THAN // Superior or equal of the value OPERATION . LOWER_OR_EQUAL_THAN // Inferior or equal of the value // Possible value of behavior on the onSort handler : const { SORT_BEHAVIOR } = QUERY ; SORT_BEHAVIOR . ASCENDING // Ascending order SORT_BEHAVIOR . DESCENDING // Descending order updateBuilder \u00b6 query.updateBuilder is used to handle the update kind of query. Like the queryBuilder you need to give him handler to build your query query . updateBuilder ({ // Apply an update operation // Key is the targeted key // Operator is the operation to make // Value is the value to apply onOperator : ({ key , operator , value , }) => {}, }) You can use the OPERATIONS constant to compare with the operator const { OPERATIONS } = require ( 'ilorm-constants' ). QUERY ; // Set the value associated with the key : OPERATIONS . SET // Increment the value associated with the key (could be a negative number to decrement) : OPERATIONS . ADD Database operation to implement \u00b6 This part list all database related method to implement in your Connector. All operations are async : count(query) : Return the number of element associated with the specified query. create(item|arrayOfItem) : The handler need to create all item into the database. find(query) : Return an array of all element linked with the specified query. findOne(query) : Return the first element linked with the specified query. remove(query) : Remove all element which match the query removeOne(query) : RemoveOne element which match the query stream(query) : Return a stream which stream all element associated with the query. update(query) : Update all element which match the query updateOne(query) : Update the first element which match the query Connector factory \u00b6 On your connector, you need to implement to more method : modelFactory : Will return a Model class linked with your connector. queryFactory : Will return a Query class linked with your connector. Both method take in parameter a base Class used as parent of the future class. modelFactory \u00b6 With ilorm, every Model are inheritance of two class minimum : BaseModel : The lowest level, this class is defined in ilorm core. FactoryModel : Overload BaseModel to specify name, schema, connector, plugin, linked with the current model. This Class is generated to every model when calling ilorm.newModel. This class is defined in ilorm core too. This class is given in parameter of ModelFactory DatabaseModel : The last mandatory level, it's the result the modelFactory, you can add every kind of specific behavior of your database here. Plugin could overload BaseModel (you can have Model inheritance between BaseModel and FactoryModel). The final user could overload your DatabaseModel. The signature of modelFactory is ; DatabaseModel result = Connector.modelFactory({ name, schema, ParentModel }); name : The name of the model, given by the developer who using your connector. schema : The schema binded with the current model. ParentModel : The FactoryModel (Your Model need to inherit from this parameter). queryFactory \u00b6 Query are similar to Model. Every query are composed by a BaseQuery (defined in core), overloaded by InternalQuery to specify the binded model. And your connector Query is the last part of the system. Plugin could overload BaseQuery. The signature of the queryFactory is : DatabaseQuery result = Connector.queryFactory({ schema, ParentQuery, }); schema : The schema binded with your query ParentQuery : The ParentQuery (your Query need to inherit from this parameter)","title":"Create connector"},{"location":"advanced/create_connector/#create-a-connector","text":"","title":"Create a connector"},{"location":"advanced/create_connector/#the-connector-class","text":"","title":"The connector class"},{"location":"advanced/create_connector/#basics","text":"To create a connector, you need to implement a class Connector. The class Connector is always linked with a database The instance of the class is linked with a table, a collection or a subset of data. Example : On a SQL database The class is linked with the full database An instance of the class is linked with a table On a MongoDB database The class linked with the full database An instance of the class is linked with a collection","title":"Basics"},{"location":"advanced/create_connector/#mandatory-operation","text":"The class need to implement mandatory operation to be fully functional. The operations are divided into : Database related : Update, Find, Create, Remove data Connector factory : The connector instantiate his own Query class or Model class to overwrite basic behavior.","title":"Mandatory operation"},{"location":"advanced/create_connector/#database-related","text":"","title":"Database related"},{"location":"advanced/create_connector/#ilorm-query","text":"The majority of database related operation receive a Query instance as parameter. You need to use this query instance to create the same query in the database language to do it. The query have some useful method : queryBuilder and updateBuilder.","title":"Ilorm query"},{"location":"advanced/create_connector/#querybuilder","text":"query.queryBuilder is use to restrict your query. You will put as parameter of queryBuilder a set of handler. Each handler should be called back (in function of the query). query . queryBuilder ({ // On option will be called if skip & limit was put : onOption : ( skip , limit ) => {}, // If an or operator is used on the query, this handler will be called // The parameter is multiple query instance (each or branch) onOr : arrayOfQuery => {}, // If one or more field are select, this handler will be called // You need to restrict result only to the specified field onSelect : ({ field , }) => {}, // Called (in order), to set the order of the result. // Key is the target sorting key // behavior precise if it's ascending or descending sorting onSort : ({ key , behavior , }) => {}, // Called per each query operation // Key is the target key // Operation is EQUAL, NOT_EQUAL... // Value is the value applied to the operation onOperator : ({ key , operation , value , }) => {} }); Behavior and operation are equal to specific constants. The constants can be found in ilorm-constants in the QUERY constants : const { QUERY , } = require ( 'ilorm-constants' ); // Possible value of operation on the onOperator handler : const { OPERATIONS } = QUERY ; OPERATION . IS // equal (===) OPERATION . IS_NOT // Not equal (!==) OPERATION . IS_IN // The value is in the specified array of possibility OPERATION . IS_NOT_IN // The value is not in the specified array of possibility OPERATION . GREATHER_THAN // Superior of the value OPERATION . LOWER_THAN // Inferior of the value OPERATION_GREATHER_OR_EQUAL_THAN // Superior or equal of the value OPERATION . LOWER_OR_EQUAL_THAN // Inferior or equal of the value // Possible value of behavior on the onSort handler : const { SORT_BEHAVIOR } = QUERY ; SORT_BEHAVIOR . ASCENDING // Ascending order SORT_BEHAVIOR . DESCENDING // Descending order","title":"queryBuilder"},{"location":"advanced/create_connector/#updatebuilder","text":"query.updateBuilder is used to handle the update kind of query. Like the queryBuilder you need to give him handler to build your query query . updateBuilder ({ // Apply an update operation // Key is the targeted key // Operator is the operation to make // Value is the value to apply onOperator : ({ key , operator , value , }) => {}, }) You can use the OPERATIONS constant to compare with the operator const { OPERATIONS } = require ( 'ilorm-constants' ). QUERY ; // Set the value associated with the key : OPERATIONS . SET // Increment the value associated with the key (could be a negative number to decrement) : OPERATIONS . ADD","title":"updateBuilder"},{"location":"advanced/create_connector/#database-operation-to-implement","text":"This part list all database related method to implement in your Connector. All operations are async : count(query) : Return the number of element associated with the specified query. create(item|arrayOfItem) : The handler need to create all item into the database. find(query) : Return an array of all element linked with the specified query. findOne(query) : Return the first element linked with the specified query. remove(query) : Remove all element which match the query removeOne(query) : RemoveOne element which match the query stream(query) : Return a stream which stream all element associated with the query. update(query) : Update all element which match the query updateOne(query) : Update the first element which match the query","title":"Database operation to implement"},{"location":"advanced/create_connector/#connector-factory","text":"On your connector, you need to implement to more method : modelFactory : Will return a Model class linked with your connector. queryFactory : Will return a Query class linked with your connector. Both method take in parameter a base Class used as parent of the future class.","title":"Connector factory"},{"location":"advanced/create_connector/#modelfactory","text":"With ilorm, every Model are inheritance of two class minimum : BaseModel : The lowest level, this class is defined in ilorm core. FactoryModel : Overload BaseModel to specify name, schema, connector, plugin, linked with the current model. This Class is generated to every model when calling ilorm.newModel. This class is defined in ilorm core too. This class is given in parameter of ModelFactory DatabaseModel : The last mandatory level, it's the result the modelFactory, you can add every kind of specific behavior of your database here. Plugin could overload BaseModel (you can have Model inheritance between BaseModel and FactoryModel). The final user could overload your DatabaseModel. The signature of modelFactory is ; DatabaseModel result = Connector.modelFactory({ name, schema, ParentModel }); name : The name of the model, given by the developer who using your connector. schema : The schema binded with the current model. ParentModel : The FactoryModel (Your Model need to inherit from this parameter).","title":"modelFactory"},{"location":"advanced/create_connector/#queryfactory","text":"Query are similar to Model. Every query are composed by a BaseQuery (defined in core), overloaded by InternalQuery to specify the binded model. And your connector Query is the last part of the system. Plugin could overload BaseQuery. The signature of the queryFactory is : DatabaseQuery result = Connector.queryFactory({ schema, ParentQuery, }); schema : The schema binded with your query ParentQuery : The ParentQuery (your Query need to inherit from this parameter)","title":"queryFactory"},{"location":"api/core/","text":"Ilorm \u00b6 Main package documentation. const ilorm = require ( 'ilorm' ); Exported class \u00b6 Ilorm.Schema \u00b6 Use to declare your schema. See Schema const { Schema } = require ( 'ilorm' ); Exported functions \u00b6 Ilorm.declareModel() \u00b6 Declare model is used to change the Model associated with the given name. Could be used to define which Class will be instancied in each case. declareModel is already called in newModel, you need to invoke it, only if you overload the resulting class of a newModel call. ilorm . declareModel ( Model ); Parameter Type Description Model Model The Model to associate with the given name. Example of declareModel userParams = { name : 'users' , // some other definition }; const BaseUser = newModel ( userParams ); const User extends BaseUser // Before declareModel ilorm associate 'users' with BaseUser ilorm . declareModel ( User ); // After ilorm associate 'users' with User, BaseUser was replaced // Now you could reference the Model User as users in your schema : const friendSchema = new Schema ({ userA : Schema . reference ( 'users' ). required (), userB : Schema . reference ( 'users' ). required (), }); Ilorm.newModel() \u00b6 Create a new Model class const { newModel } = require ( 'ilorm' ); const Model = newModel ({ name , schema , connector }) Return a class Model you can use in your project to create new data or query. Parameter Type Default Description name String, Symbol Symbol('model') The unique name of the model, could be use to reference object. schema Schema none Specify the schema associated with the given model. connector Connector none Specify the connector to use with the given model Tip You can extends the created Model to add specific behavior of your code. class YourModel extends newModel ( conf ) {} Example of extends Model class User extends newModel ( userConf ) { static queryMale () { return super . query () . gender . is ( 'M' ); } } Example of newModel Full example of creating a UserModel const { Schema , newModel } = require ( 'ilorm' ); const mongoConnector = require ( './mongoConnector' ); const userSchema = new Schema ({ firstName : Schema . string (). required (), lastName : Schema . string (). required (), birthday : Schema . date (), weight : Schema . number (), isLogged : Schema . boolean (). required (), }); const UserModel = newModel ({ name : 'users' , schema : userSchema , connector : mongoConnector , }); Ilorm.use() \u00b6","title":"Core"},{"location":"api/core/#ilorm","text":"Main package documentation. const ilorm = require ( 'ilorm' );","title":"Ilorm"},{"location":"api/core/#exported-class","text":"","title":"Exported class"},{"location":"api/core/#ilormschema","text":"Use to declare your schema. See Schema const { Schema } = require ( 'ilorm' );","title":"Ilorm.Schema"},{"location":"api/core/#exported-functions","text":"","title":"Exported functions"},{"location":"api/core/#ilormdeclaremodel","text":"Declare model is used to change the Model associated with the given name. Could be used to define which Class will be instancied in each case. declareModel is already called in newModel, you need to invoke it, only if you overload the resulting class of a newModel call. ilorm . declareModel ( Model ); Parameter Type Description Model Model The Model to associate with the given name. Example of declareModel userParams = { name : 'users' , // some other definition }; const BaseUser = newModel ( userParams ); const User extends BaseUser // Before declareModel ilorm associate 'users' with BaseUser ilorm . declareModel ( User ); // After ilorm associate 'users' with User, BaseUser was replaced // Now you could reference the Model User as users in your schema : const friendSchema = new Schema ({ userA : Schema . reference ( 'users' ). required (), userB : Schema . reference ( 'users' ). required (), });","title":"Ilorm.declareModel()"},{"location":"api/core/#ilormnewmodel","text":"Create a new Model class const { newModel } = require ( 'ilorm' ); const Model = newModel ({ name , schema , connector }) Return a class Model you can use in your project to create new data or query. Parameter Type Default Description name String, Symbol Symbol('model') The unique name of the model, could be use to reference object. schema Schema none Specify the schema associated with the given model. connector Connector none Specify the connector to use with the given model Tip You can extends the created Model to add specific behavior of your code. class YourModel extends newModel ( conf ) {} Example of extends Model class User extends newModel ( userConf ) { static queryMale () { return super . query () . gender . is ( 'M' ); } } Example of newModel Full example of creating a UserModel const { Schema , newModel } = require ( 'ilorm' ); const mongoConnector = require ( './mongoConnector' ); const userSchema = new Schema ({ firstName : Schema . string (). required (), lastName : Schema . string (). required (), birthday : Schema . date (), weight : Schema . number (), isLogged : Schema . boolean (). required (), }); const UserModel = newModel ({ name : 'users' , schema : userSchema , connector : mongoConnector , });","title":"Ilorm.newModel()"},{"location":"api/core/#ilormuse","text":"","title":"Ilorm.use()"},{"location":"api/model/","text":"Model \u00b6 Model could not be created directly. To access this API, you need to invoke the newModel method from ilorm. And create your own child model. (static) Model.query() \u00b6 Create a Query instance targeting the current Model. const query = Model . query (); Return a query instance linked with the current Model. Example of query UserModel is a Model with a numberField : weight . const user = async UserModel . query () . weight . min ( 80 ) . findOne (); (static) (async) Model.getById() \u00b6 Get an instance of the model by it's Id. const modelInstance = await Model . getById ( id ); Return the instance associated with the given id. Parameter Type Default Description id Mixing The id of the instance to get. (async) Model.save() \u00b6 Save the current instance into the database. - If the instance exists, it will make an update with the updated field only. - If the instance does not exists. It will create the instance into the database. await modelInstance . save (); (async) Model.remove() \u00b6 Remove the current instance from the database. await modelInstance . remove ();","title":"Model"},{"location":"api/model/#model","text":"Model could not be created directly. To access this API, you need to invoke the newModel method from ilorm. And create your own child model.","title":"Model"},{"location":"api/model/#static-modelquery","text":"Create a Query instance targeting the current Model. const query = Model . query (); Return a query instance linked with the current Model. Example of query UserModel is a Model with a numberField : weight . const user = async UserModel . query () . weight . min ( 80 ) . findOne ();","title":"(static) Model.query()"},{"location":"api/model/#staticasync-modelgetbyid","text":"Get an instance of the model by it's Id. const modelInstance = await Model . getById ( id ); Return the instance associated with the given id. Parameter Type Default Description id Mixing The id of the instance to get.","title":"(static)(async) Model.getById()"},{"location":"api/model/#async-modelsave","text":"Save the current instance into the database. - If the instance exists, it will make an update with the updated field only. - If the instance does not exists. It will create the instance into the database. await modelInstance . save ();","title":"(async) Model.save()"},{"location":"api/model/#async-modelremove","text":"Remove the current instance from the database. await modelInstance . remove ();","title":"(async) Model.remove()"},{"location":"api/query/","text":"Query \u00b6 Query is a class which could be only instancied with the query static method of model . Query is a query builder used to run operation on your database. Like find an instance or update multiple instance. Query work directly in function of your schema. Every field declared on your schema are defined as attribute of the Query. You can split your query into two things : - The query building part : You choose what your query will do. - The query run part : You choose the operation to do and execute the query. Query building \u00b6 Query building are in function of the field of your schema. All method are children of attribute defined in your schema. Little example With this kind of schema : const invoice = new Schema ({ date : Schema . date (). required (), amount : Schema . number (). required (), }) You could use this kind of query : const invoice = await Invoices . query () . amount . greaterThan ( 100 ) // amount is here in function of your schema . findOne (); Query. [field] .is() \u00b6 Check if the [field] is equal of the specified value. Query . field . is ( value ); Returns a query to chain call. Parameter Type Description value Mixing The field need to be equal of this value. Query. [field] .isNot() \u00b6 Check if the [field] is not equal of the specified value. Query . field . isNot ( value ); Returns a query to chain call. Parameter Type Description value Mixing The field need to be different of this value. Query. [field] .isIn() \u00b6 Check if the [field] is a member of the parameter array Query . field . isIn ( arrayOfValue ); Returns a query to chain call. Parameter Type Description arrayOfValue Array.<Mixing> The field need to be equal at one array element. Query. [field] .isNotIn() \u00b6 Check if the [field] is not one of the array value. Query . field . isNotIn ( arrayOfValue ); Returns a query to chain call. Parameter Type Description arrayOfValue Array.<Mixing> The field need to be different of each array element. Query. [field] .greaterThan() \u00b6 Check if the [field] is greater than the specified value. Query . field . greaterThan ( value ); Returns a query to chain call. Parameter Type Description value Mixing The field need to be greater than value. Info Only work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField). Query. [field] .lowerThan() \u00b6 Check if the [field] is lower than the specified value. Query . field . lowerThan ( value ); Returns a query to chain call. Parameter Type Description value Mixing The field need to be lower than value. Info Only work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField). Query. [field] .greaterOrEqualThan() \u00b6 Check if the [field] is equal or greater than the specified value. Query . field . greaterOrEqualThan ( value ); Returns a query to chain call. Parameter Type Description value Mixing The field need to be equal or grater than value. Info Only work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField). Query. [field] .lowerOrEqualThan() \u00b6 Check if the [field] is equal or lower than specified value. Query . field . lowerOrEqualThan ( value ); Returns a query to chain call. Parameter Type Description value Mixing The field need to be equal or lower than value. Info Only work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField). Query. [field] .between() \u00b6 Check if the [field] is between min and max. Query . field . between ( min , max ); Returns a query to chain call. Parameter Type Description min Mixing The field need to be greater than min. max Mixing The field need to be lower than max. Info Only work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField). Select specific fields \u00b6 Query. [field] .select() \u00b6 Use to target specific field to be returned by the query. The [field] will be part of the output result. Query . field . select (); Info The json object resulting of the query will not be an instance anymore! If you want to select only one field, you could use selectOnly Query. [field] .selectOnly() \u00b6 Use to target specific field to be returned by the query. Only the [field] will be part of the output result. Query . field . selectOnly (); Example of selectOnly const email = await User . query () . _id . is ( TARGET_ID ) . email . selectOnly () . findOne (); query.or() \u00b6 Creating branch. Query . or ( orHandler ) Parameter Type Description orHandler Function Take a function in parameter used to build subquery Example of or const email = await User . query () . or ( orBranch => { orBranch (). email . is ( 'email' ); orBranch (). email . is ( 'alternativeEmail' ); }) . findOne (); Query sorting \u00b6 Query. [field] .useAsSortAsc() \u00b6 Sorting the result ascending of the query by the given field. Query . field . useAsSortAsc (); Query. [field] .useAsSortDesc() \u00b6 Sorting the result descending of the query by the given field. Query . field . useAsSortDesc (); Query pagination \u00b6 Query.skip() \u00b6 Skip a number of element before getting the result. Query . skip ( nbToSkip ); Parameter Type Description nbToSkip Number The amount of element to skip before starting gathering result. Query.limit() \u00b6 Limit the number of element impacted by the query. Query . limit ( nbToImpact ); Parameter Type Description nbToImpact Number The amount of element to fetch or update or remove. Query running \u00b6 (async) Query.findOne() \u00b6 Execute the query, and returns one element which match it. const instance = await query . findOne (); Return one instance which match the query. (async) Query.find() \u00b6 Execute the query, and returns one array containing all elements which match the query. const arrayOfInstances = await query . find (); Return all instance which match the query. (async) Query.stream() \u00b6 Execute the query, and returns the stream of all elements matching the query const streamOfInstances = await query . stream (); Return a stream containing all elements matching the query. (async) Query.count() \u00b6 Execute the query, and return how many item match the query. const numberOfInstance = await query . count (); Return the number of instance which match the query. (async) Query.updateOne() \u00b6 (async) Query.update() \u00b6 (async) Query.removeOne() \u00b6 (async) Query.remove() \u00b6","title":"Query"},{"location":"api/query/#query","text":"Query is a class which could be only instancied with the query static method of model . Query is a query builder used to run operation on your database. Like find an instance or update multiple instance. Query work directly in function of your schema. Every field declared on your schema are defined as attribute of the Query. You can split your query into two things : - The query building part : You choose what your query will do. - The query run part : You choose the operation to do and execute the query.","title":"Query"},{"location":"api/query/#query-building","text":"Query building are in function of the field of your schema. All method are children of attribute defined in your schema. Little example With this kind of schema : const invoice = new Schema ({ date : Schema . date (). required (), amount : Schema . number (). required (), }) You could use this kind of query : const invoice = await Invoices . query () . amount . greaterThan ( 100 ) // amount is here in function of your schema . findOne ();","title":"Query building"},{"location":"api/query/#queryfieldis","text":"Check if the [field] is equal of the specified value. Query . field . is ( value ); Returns a query to chain call. Parameter Type Description value Mixing The field need to be equal of this value.","title":"Query.[field].is()"},{"location":"api/query/#queryfieldisnot","text":"Check if the [field] is not equal of the specified value. Query . field . isNot ( value ); Returns a query to chain call. Parameter Type Description value Mixing The field need to be different of this value.","title":"Query.[field].isNot()"},{"location":"api/query/#queryfieldisin","text":"Check if the [field] is a member of the parameter array Query . field . isIn ( arrayOfValue ); Returns a query to chain call. Parameter Type Description arrayOfValue Array.<Mixing> The field need to be equal at one array element.","title":"Query.[field].isIn()"},{"location":"api/query/#queryfieldisnotin","text":"Check if the [field] is not one of the array value. Query . field . isNotIn ( arrayOfValue ); Returns a query to chain call. Parameter Type Description arrayOfValue Array.<Mixing> The field need to be different of each array element.","title":"Query.[field].isNotIn()"},{"location":"api/query/#queryfieldgreaterthan","text":"Check if the [field] is greater than the specified value. Query . field . greaterThan ( value ); Returns a query to chain call. Parameter Type Description value Mixing The field need to be greater than value. Info Only work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField).","title":"Query.[field].greaterThan()"},{"location":"api/query/#queryfieldlowerthan","text":"Check if the [field] is lower than the specified value. Query . field . lowerThan ( value ); Returns a query to chain call. Parameter Type Description value Mixing The field need to be lower than value. Info Only work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField).","title":"Query.[field].lowerThan()"},{"location":"api/query/#queryfieldgreaterorequalthan","text":"Check if the [field] is equal or greater than the specified value. Query . field . greaterOrEqualThan ( value ); Returns a query to chain call. Parameter Type Description value Mixing The field need to be equal or grater than value. Info Only work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField).","title":"Query.[field].greaterOrEqualThan()"},{"location":"api/query/#queryfieldlowerorequalthan","text":"Check if the [field] is equal or lower than specified value. Query . field . lowerOrEqualThan ( value ); Returns a query to chain call. Parameter Type Description value Mixing The field need to be equal or lower than value. Info Only work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField).","title":"Query.[field].lowerOrEqualThan()"},{"location":"api/query/#queryfieldbetween","text":"Check if the [field] is between min and max. Query . field . between ( min , max ); Returns a query to chain call. Parameter Type Description min Mixing The field need to be greater than min. max Mixing The field need to be lower than max. Info Only work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField).","title":"Query.[field].between()"},{"location":"api/query/#select-specific-fields","text":"","title":"Select specific fields"},{"location":"api/query/#queryfieldselect","text":"Use to target specific field to be returned by the query. The [field] will be part of the output result. Query . field . select (); Info The json object resulting of the query will not be an instance anymore! If you want to select only one field, you could use selectOnly","title":"Query.[field].select()"},{"location":"api/query/#queryfieldselectonly","text":"Use to target specific field to be returned by the query. Only the [field] will be part of the output result. Query . field . selectOnly (); Example of selectOnly const email = await User . query () . _id . is ( TARGET_ID ) . email . selectOnly () . findOne ();","title":"Query.[field].selectOnly()"},{"location":"api/query/#queryor","text":"Creating branch. Query . or ( orHandler ) Parameter Type Description orHandler Function Take a function in parameter used to build subquery Example of or const email = await User . query () . or ( orBranch => { orBranch (). email . is ( 'email' ); orBranch (). email . is ( 'alternativeEmail' ); }) . findOne ();","title":"query.or()"},{"location":"api/query/#query-sorting","text":"","title":"Query sorting"},{"location":"api/query/#queryfielduseassortasc","text":"Sorting the result ascending of the query by the given field. Query . field . useAsSortAsc ();","title":"Query.[field].useAsSortAsc()"},{"location":"api/query/#queryfielduseassortdesc","text":"Sorting the result descending of the query by the given field. Query . field . useAsSortDesc ();","title":"Query.[field].useAsSortDesc()"},{"location":"api/query/#query-pagination","text":"","title":"Query pagination"},{"location":"api/query/#queryskip","text":"Skip a number of element before getting the result. Query . skip ( nbToSkip ); Parameter Type Description nbToSkip Number The amount of element to skip before starting gathering result.","title":"Query.skip()"},{"location":"api/query/#querylimit","text":"Limit the number of element impacted by the query. Query . limit ( nbToImpact ); Parameter Type Description nbToImpact Number The amount of element to fetch or update or remove.","title":"Query.limit()"},{"location":"api/query/#query-running","text":"","title":"Query running"},{"location":"api/query/#async-queryfindone","text":"Execute the query, and returns one element which match it. const instance = await query . findOne (); Return one instance which match the query.","title":"(async) Query.findOne()"},{"location":"api/query/#async-queryfind","text":"Execute the query, and returns one array containing all elements which match the query. const arrayOfInstances = await query . find (); Return all instance which match the query.","title":"(async) Query.find()"},{"location":"api/query/#async-querystream","text":"Execute the query, and returns the stream of all elements matching the query const streamOfInstances = await query . stream (); Return a stream containing all elements matching the query.","title":"(async) Query.stream()"},{"location":"api/query/#async-querycount","text":"Execute the query, and return how many item match the query. const numberOfInstance = await query . count (); Return the number of instance which match the query.","title":"(async) Query.count()"},{"location":"api/query/#async-queryupdateone","text":"","title":"(async) Query.updateOne()"},{"location":"api/query/#async-queryupdate","text":"","title":"(async) Query.update()"},{"location":"api/query/#async-queryremoveone","text":"","title":"(async) Query.removeOne()"},{"location":"api/query/#async-queryremove","text":"","title":"(async) Query.remove()"},{"location":"api/schema/","text":"Schema \u00b6 Schema define how your data are stored. Example of schema Basic example of what a schema \"user\" could look like : const { Schema } = require ( 'ilorm' ); const userSchema = new Schema ({ firstName : Schema . string (). required (), lastName : Schema . string (). required (), birthday : Schema . date (), weight : Schema . number (), isLogged : Schema . boolean (). required (), }); constructor Schema() \u00b6 Instantiate a new schema object. new Schema ( schemaDefinition ); Parameter Type Description schemaDefinition Object An object ; { key: SchemaField } where every key will be the name of the field in the model, and SchemaField the definition of the field. (static) Schema.boolean() \u00b6 Factory to create a Boolean . Schema . boolean () Return a Boolean instance . Example of boolean Basic example of what a schema \"user\" could look like : const { Schema } = require ( 'ilorm' ); const userSchema = new Schema ({ firstName : Schema . string (). required (), lastName : Schema . string (). required (), birthday : Schema . date (), weight : Schema . number (), isLogged : Schema . boolean (). required (), }); (static) Schema.date() \u00b6 Factory to create a Date . Schema . date () Return a Date instance . Example of date Basic example of what a schema \"user\" could look like : const { Schema } = require ( 'ilorm' ); const userSchema = new Schema ({ firstName : Schema . string (). required (), lastName : Schema . string (). required (), birthday : Schema . date (), weight : Schema . number (), isLogged : Schema . boolean (). required (), }); (static) Schema.number() \u00b6 Factory to create a Number . Schema . number () Return a Number instance . Example of number Basic example of what a schema \"user\" could look like : const { Schema } = require ( 'ilorm' ); const userSchema = new Schema ({ firstName : Schema . string (). required (), lastName : Schema . string (). required (), birthday : Schema . date (), weight : Schema . number (), isLogged : Schema . boolean (). required (), }); (static) Schema.reference() \u00b6 Factory to create a Reference . Schema . reference ( modelName ) Parameter Type Description modelName String Specify which model is linked with the given reference. Return a Reference instance . Example of reference Basic example of what a schema \"user\" could look like : const { Schema } = require ( 'ilorm' ); const userSchema = new Schema ({ firstName : Schema . string (). required (), lastName : Schema . string (). required (), father : Schema . reference ( 'users' ), }); (static) Schema.string() \u00b6 Factory to create a String . Schema . string () Return a String instance . Example of string Basic example of what a schema \"user\" could look like : const { Schema } = require ( 'ilorm' ); const userSchema = new Schema ({ firstName : Schema . string (). required (), lastName : Schema . string (). required (), birthday : Schema . date (), weight : Schema . number (), isLogged : Schema . boolean (). required (), });","title":"Schema"},{"location":"api/schema/#schema","text":"Schema define how your data are stored. Example of schema Basic example of what a schema \"user\" could look like : const { Schema } = require ( 'ilorm' ); const userSchema = new Schema ({ firstName : Schema . string (). required (), lastName : Schema . string (). required (), birthday : Schema . date (), weight : Schema . number (), isLogged : Schema . boolean (). required (), });","title":"Schema"},{"location":"api/schema/#constructor-schema","text":"Instantiate a new schema object. new Schema ( schemaDefinition ); Parameter Type Description schemaDefinition Object An object ; { key: SchemaField } where every key will be the name of the field in the model, and SchemaField the definition of the field.","title":"constructor Schema()"},{"location":"api/schema/#static-schemaboolean","text":"Factory to create a Boolean . Schema . boolean () Return a Boolean instance . Example of boolean Basic example of what a schema \"user\" could look like : const { Schema } = require ( 'ilorm' ); const userSchema = new Schema ({ firstName : Schema . string (). required (), lastName : Schema . string (). required (), birthday : Schema . date (), weight : Schema . number (), isLogged : Schema . boolean (). required (), });","title":"(static) Schema.boolean()"},{"location":"api/schema/#static-schemadate","text":"Factory to create a Date . Schema . date () Return a Date instance . Example of date Basic example of what a schema \"user\" could look like : const { Schema } = require ( 'ilorm' ); const userSchema = new Schema ({ firstName : Schema . string (). required (), lastName : Schema . string (). required (), birthday : Schema . date (), weight : Schema . number (), isLogged : Schema . boolean (). required (), });","title":"(static) Schema.date()"},{"location":"api/schema/#static-schemanumber","text":"Factory to create a Number . Schema . number () Return a Number instance . Example of number Basic example of what a schema \"user\" could look like : const { Schema } = require ( 'ilorm' ); const userSchema = new Schema ({ firstName : Schema . string (). required (), lastName : Schema . string (). required (), birthday : Schema . date (), weight : Schema . number (), isLogged : Schema . boolean (). required (), });","title":"(static) Schema.number()"},{"location":"api/schema/#static-schemareference","text":"Factory to create a Reference . Schema . reference ( modelName ) Parameter Type Description modelName String Specify which model is linked with the given reference. Return a Reference instance . Example of reference Basic example of what a schema \"user\" could look like : const { Schema } = require ( 'ilorm' ); const userSchema = new Schema ({ firstName : Schema . string (). required (), lastName : Schema . string (). required (), father : Schema . reference ( 'users' ), });","title":"(static) Schema.reference()"},{"location":"api/schema/#static-schemastring","text":"Factory to create a String . Schema . string () Return a String instance . Example of string Basic example of what a schema \"user\" could look like : const { Schema } = require ( 'ilorm' ); const userSchema = new Schema ({ firstName : Schema . string (). required (), lastName : Schema . string (). required (), birthday : Schema . date (), weight : Schema . number (), isLogged : Schema . boolean (). required (), });","title":"(static) Schema.string()"},{"location":"api/schemaFields/","text":"SchemaField \u00b6 SchemaField is a class used to define the behavior of your fields. Every field type are children of the SchemaField class. The SchemaField class is an abstract class. You can create your own custom field by inheritance with SchemaField. SchemaField.default() \u00b6 Specify the default value of the field, if no value are provided. const field = new SchemaField (); field . default ( value ); Parameter Type Description value * Define the default value of the field. Example of default Basic example of what a schema \"user\" could look like : const { Schema } = require ( 'ilorm' ); const userSchema = new Schema ({ firstName : Schema . string (). required (), lastName : Schema . string (). required (), birthday : Schema . date (), weight : Schema . number (), isLogged : Schema . boolean (). default ( true ). required (), }); SchemaField.required() \u00b6 Specify the field as required. A required field is mandatory to be save. An instance without mandatory field throw error. const field = new SchemaField (); field . required ( isRequired = true ); Parameter Type Default Description isRequired Boolean true Define the field as required (or not). Per default, the field is always not required. By calling this method, without parameter you change the required status. Example of required Basic example of what a schema \"user\" could look like : const { Schema } = require ( 'ilorm' ); const userSchema = new Schema ({ firstName : Schema . string (). required (), lastName : Schema . string (). required (), birthday : Schema . date (), weight : Schema . number (), isLogged : Schema . boolean (). default ( true ). required (), }); SchemaField/Boolean \u00b6 Define the field as boolean. SchemaField/Date \u00b6 Define the field as date. SchemaField/Number \u00b6 Define the field as number. SchemaField/Reference \u00b6 Define the field as reference. SchemaField/String \u00b6 Define the field as string.","title":"Schema Field"},{"location":"api/schemaFields/#schemafield","text":"SchemaField is a class used to define the behavior of your fields. Every field type are children of the SchemaField class. The SchemaField class is an abstract class. You can create your own custom field by inheritance with SchemaField.","title":"SchemaField"},{"location":"api/schemaFields/#schemafielddefault","text":"Specify the default value of the field, if no value are provided. const field = new SchemaField (); field . default ( value ); Parameter Type Description value * Define the default value of the field. Example of default Basic example of what a schema \"user\" could look like : const { Schema } = require ( 'ilorm' ); const userSchema = new Schema ({ firstName : Schema . string (). required (), lastName : Schema . string (). required (), birthday : Schema . date (), weight : Schema . number (), isLogged : Schema . boolean (). default ( true ). required (), });","title":"SchemaField.default()"},{"location":"api/schemaFields/#schemafieldrequired","text":"Specify the field as required. A required field is mandatory to be save. An instance without mandatory field throw error. const field = new SchemaField (); field . required ( isRequired = true ); Parameter Type Default Description isRequired Boolean true Define the field as required (or not). Per default, the field is always not required. By calling this method, without parameter you change the required status. Example of required Basic example of what a schema \"user\" could look like : const { Schema } = require ( 'ilorm' ); const userSchema = new Schema ({ firstName : Schema . string (). required (), lastName : Schema . string (). required (), birthday : Schema . date (), weight : Schema . number (), isLogged : Schema . boolean (). default ( true ). required (), });","title":"SchemaField.required()"},{"location":"api/schemaFields/#schemafieldboolean","text":"Define the field as boolean.","title":"SchemaField/Boolean"},{"location":"api/schemaFields/#schemafielddate","text":"Define the field as date.","title":"SchemaField/Date"},{"location":"api/schemaFields/#schemafieldnumber","text":"Define the field as number.","title":"SchemaField/Number"},{"location":"api/schemaFields/#schemafieldreference","text":"Define the field as reference.","title":"SchemaField/Reference"},{"location":"api/schemaFields/#schemafieldstring","text":"Define the field as string.","title":"SchemaField/String"},{"location":"connectors/intro/","text":"Connectors are object representing a connection to a database (or others data source). List of connectors \u00b6 Knex (Support MySQL, PostgreSQL, Oracle, Redshift, MariaDB, SQLite ...). MongoDB","title":"Intro"},{"location":"connectors/intro/#list-of-connectors","text":"Knex (Support MySQL, PostgreSQL, Oracle, Redshift, MariaDB, SQLite ...). MongoDB","title":"List of connectors"},{"location":"connectors/knex/","text":"ilorm-connector-knex \u00b6 The Knex connector is the Connector to use knex compatible database as storage for your model. Features \u00b6 Support all Knex supported database How it works \u00b6 To use this connector : first declare it in your project : const ilorm = require ( 'ilorm' ); const ilormKnex = require ( 'ilorm-connector-knex' ); ilorm . use ( ilormKnex ); Second, you need to create a KnexConnector. To do that, you need to make a connection between your database and your project. You need knex to achieve that: const knex = require ( 'knex' )({ client : 'mysql2' , connection : { host : '127.0.0.1' , user : 'root' , password : 'someSecretPassword' , database : 'yourDb' , }, }); const ilormKnex = require ( 'ilorm-connector-knex' ); const knexConnection = IlormKnex . fromKnex ( knex ); Finally you need to choose the table used to store your model : const modelFactoryParams = { name : 'users' , schema : userSchema , connector : new knexConnection ({ tableName : 'users' }), }; const UserModel = newModel ( modelFactoryParams );","title":"Knex"},{"location":"connectors/knex/#ilorm-connector-knex","text":"The Knex connector is the Connector to use knex compatible database as storage for your model.","title":"ilorm-connector-knex"},{"location":"connectors/knex/#features","text":"Support all Knex supported database","title":"Features"},{"location":"connectors/knex/#how-it-works","text":"To use this connector : first declare it in your project : const ilorm = require ( 'ilorm' ); const ilormKnex = require ( 'ilorm-connector-knex' ); ilorm . use ( ilormKnex ); Second, you need to create a KnexConnector. To do that, you need to make a connection between your database and your project. You need knex to achieve that: const knex = require ( 'knex' )({ client : 'mysql2' , connection : { host : '127.0.0.1' , user : 'root' , password : 'someSecretPassword' , database : 'yourDb' , }, }); const ilormKnex = require ( 'ilorm-connector-knex' ); const knexConnection = IlormKnex . fromKnex ( knex ); Finally you need to choose the table used to store your model : const modelFactoryParams = { name : 'users' , schema : userSchema , connector : new knexConnection ({ tableName : 'users' }), }; const UserModel = newModel ( modelFactoryParams );","title":"How it works"},{"location":"connectors/mongodb/","text":"ilorm-connector-mongo \u00b6 The MongoDB connector is the Connector to use mongoDB as storage for your ilorm model. Features \u00b6 Add MongoDB as connector. Add specifics MongoDB SchemaFields : Array, Map, Object and ObjectId. Add specifics MongoDB query operator : push (on Array only). Add Model.aggregate to build aggregation pipeline. How it works \u00b6 To use this connector : first declare it in your project : const ilorm = require ( 'ilorm' ); const ilormMongo = require ( 'ilorm-connector-mongodb' ); ilorm . use ( ilormMongo ); Second, you need to create a MongoConnector. To do that, you need to make a connection between your database and your project. You can create it with a basic mongo client : const ilormMongo = require ( 'ilorm-connector-mongodb' ); const { MongoClient , } = require ( 'mongodb' ); const DB_URL = 'mongodb://localhost:27017/ilorm' ; const mongoClient = await MongoClient . connect ( DB_URL ); const database = await mongoClient . db ( 'ilorm' ); const MongoConnector = ilormMongo . fromClient ( database ); Finally you need to choose the collection used to store your model : const modelFactoryParams = { name : 'users' , schema : userSchema , connector : new MongoConnector ({ collectionName : 'users' , }), }; const UserModel = newModel ( modelFactoryParams ); Connector \u00b6 (constructor) Connector \u00b6 Model \u00b6 Query \u00b6 Schema \u00b6 SchemaField \u00b6 Array \u00b6 Array is used to define embed array in your Schema. You could define behavior of the child element. // To store users in a array ; new Schema ({ users : Schema . array ({ firstName : Schema . String (), lastName : Schema . string () }), }); Map \u00b6 Map is used to define Map in your Schema. A map is a key: value association. You can define behavior of the child element (the value of the array). And the format of your key. Object \u00b6 Object is used to define embed Object in your Schema. You could define behavior of the child element. ObjectId \u00b6 ObjectId is the ID system used by MongoDB.","title":"MongoDB"},{"location":"connectors/mongodb/#ilorm-connector-mongo","text":"The MongoDB connector is the Connector to use mongoDB as storage for your ilorm model.","title":"ilorm-connector-mongo"},{"location":"connectors/mongodb/#features","text":"Add MongoDB as connector. Add specifics MongoDB SchemaFields : Array, Map, Object and ObjectId. Add specifics MongoDB query operator : push (on Array only). Add Model.aggregate to build aggregation pipeline.","title":"Features"},{"location":"connectors/mongodb/#how-it-works","text":"To use this connector : first declare it in your project : const ilorm = require ( 'ilorm' ); const ilormMongo = require ( 'ilorm-connector-mongodb' ); ilorm . use ( ilormMongo ); Second, you need to create a MongoConnector. To do that, you need to make a connection between your database and your project. You can create it with a basic mongo client : const ilormMongo = require ( 'ilorm-connector-mongodb' ); const { MongoClient , } = require ( 'mongodb' ); const DB_URL = 'mongodb://localhost:27017/ilorm' ; const mongoClient = await MongoClient . connect ( DB_URL ); const database = await mongoClient . db ( 'ilorm' ); const MongoConnector = ilormMongo . fromClient ( database ); Finally you need to choose the collection used to store your model : const modelFactoryParams = { name : 'users' , schema : userSchema , connector : new MongoConnector ({ collectionName : 'users' , }), }; const UserModel = newModel ( modelFactoryParams );","title":"How it works"},{"location":"connectors/mongodb/#connector","text":"","title":"Connector"},{"location":"connectors/mongodb/#constructor-connector","text":"","title":"(constructor) Connector"},{"location":"connectors/mongodb/#model","text":"","title":"Model"},{"location":"connectors/mongodb/#query","text":"","title":"Query"},{"location":"connectors/mongodb/#schema","text":"","title":"Schema"},{"location":"connectors/mongodb/#schemafield","text":"","title":"SchemaField"},{"location":"connectors/mongodb/#array","text":"Array is used to define embed array in your Schema. You could define behavior of the child element. // To store users in a array ; new Schema ({ users : Schema . array ({ firstName : Schema . String (), lastName : Schema . string () }), });","title":"Array"},{"location":"connectors/mongodb/#map","text":"Map is used to define Map in your Schema. A map is a key: value association. You can define behavior of the child element (the value of the array). And the format of your key.","title":"Map"},{"location":"connectors/mongodb/#object","text":"Object is used to define embed Object in your Schema. You could define behavior of the child element.","title":"Object"},{"location":"connectors/mongodb/#objectid","text":"ObjectId is the ID system used by MongoDB.","title":"ObjectId"}]}
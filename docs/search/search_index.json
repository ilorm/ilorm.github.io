{
    "docs": [
        {
            "location": "/", 
            "text": "Ilorm index\n\n\nWelcome to the ilorm documentation! \nQuick start guide\n.\n\n\nIlorm is a javascript ORM build with modern technologies.\n\n\nCome here to discover the \nIlorm API\n.\n\n\nWhy a new ORM ?\n\n\n\n\nUse newest feature of ECMAScript (modern javascript).\n\n\nUniversal database connector (MongoDB, SQL, Redis, REST, CSV...).\n\n\nCould create powerful plugin using the \"class\" inheritance.\n\n\n\n\nFeatures\n\n\n\n\nUniversal connector to bind every kind of database\n\n\nPowerful plugin ecosystem\n\n\nQuery builder\n\n\nData validation\n\n\n\n\nStart with ilorm\n\n\n\n\nAPI\n\n\n\n\nAdvanced subject\n\n\n\n\nCreate a connector\n\n\n\n\nResources\n\n\nConnectors\n\n\n\n\nMongoDB connector\n\n\n\n\nPlugins\n\n\nWork in progress", 
            "title": "Home"
        }, 
        {
            "location": "/#ilorm-index", 
            "text": "Welcome to the ilorm documentation!  Quick start guide .  Ilorm is a javascript ORM build with modern technologies.  Come here to discover the  Ilorm API .", 
            "title": "Ilorm index"
        }, 
        {
            "location": "/#why-a-new-orm", 
            "text": "Use newest feature of ECMAScript (modern javascript).  Universal database connector (MongoDB, SQL, Redis, REST, CSV...).  Could create powerful plugin using the \"class\" inheritance.", 
            "title": "Why a new ORM ?"
        }, 
        {
            "location": "/#features", 
            "text": "Universal connector to bind every kind of database  Powerful plugin ecosystem  Query builder  Data validation", 
            "title": "Features"
        }, 
        {
            "location": "/#start-with-ilorm", 
            "text": "API", 
            "title": "Start with ilorm"
        }, 
        {
            "location": "/#advanced-subject", 
            "text": "Create a connector", 
            "title": "Advanced subject"
        }, 
        {
            "location": "/#resources", 
            "text": "", 
            "title": "Resources"
        }, 
        {
            "location": "/#connectors", 
            "text": "MongoDB connector", 
            "title": "Connectors"
        }, 
        {
            "location": "/#plugins", 
            "text": "Work in progress", 
            "title": "Plugins"
        }, 
        {
            "location": "/quick_start/", 
            "text": "Quick start\n\n\nIlorm are based on five core concepts : Connector, Model, Schema, SchemaField and Query.\n- Connectors are the definition which kind of database you use to store your data.\n- Model are class representing your data.\n- Schema define your model behavior (fields type)\n- SchemaField define the behavior of your data field.\n- Query is a powerful query builder tool to edit, delete, get data...\n\n\nInstall ilorm\n\n\nFirst install ilorm :\n\nnpm install ilorm\n\n\n\nAfter you can install the mongo-connector :\n\nnpm install ilorm-connector-mongodb\n\n\n\nYou can use another connector if you use different kind of database.\n\n\nDefine a schema\n\n\nTo define your schema, just use the Schema class of ilorm\n\nconst\n \n{\n \nSchema\n,\n \n}\n \n=\n \nrequire\n(\nilorm\n);\n\n\n\nconst\n \ninvoiceSchema\n \n=\n \nnew\n \nSchema\n({\n\n  \ncreatedAt\n:\n \nSchema\n.\ndate\n(),\n\n  \namount\n:\n \nSchema\n.\nnumber\n()\n\n\n});\n\n\n\nWith this code, you have a basic schema with two properties :\n- createdAt which will be a date.\n- amount which will be a number.\n\n\nPrepare your Connector\n\n\nconst\n \nMongoClient\n \n=\n \nrequire\n(\nmongodb\n);\n\n\nconst\n \nilorm\n \n=\n \nrequire\n(\nilorm\n);\n\n\nconst\n \nIlormMongo\n \n=\n \nrequire\n(\nilorm-connector-mongodb\n);\n\n\n\n// Declare you use ilormMongo (init plugin part of the connector) :\n\n\nilorm\n.\nuse\n(\nIlormMongo\n);\n\n\n\n// Create a database :\n\n\nconst\n \nmongoClient\n \n=\n \nawait\n \nMongoClient\n.\nconnect\n(\nDB_URL\n);\n\n\nconst\n \ndatabase\n \n=\n \nawait\n \nmongoClient\n.\ndb\n(\nilorm\n);\n\n\n\n// Create your Connector class binded with your database :\n\n\nconst\n \nMongoConnector\n \n=\n \nIlormMongo\n.\nfromClient\n(\ndatabase\n);\n\n\n\n// Create an instance of your connector. It will save in the collection: accounts ;\n\n\nconst\n \ninvoiceConnector\n \n=\n \nnew\n \nMongoConnector\n({\n \ncollection\n:\n \ninvoices\n \n});\n\n\n\nNow you have an invoiceConnector, it will save the binded model in the collection \ninvoices\n.\n\n\nCreate your model\n\n\nconst\n \n{\n \nnewModel\n,\n \n}\n \n=\n \nrequire\n(\nilorm\n);\n\n\n\nconst\n \nmodelConfig\n \n=\n \n{\n\n  \nname\n:\n \ninvoices\n,\n \n// Optional, could be useful to know the model name\n\n  \nschema\n:\n \ninvoiceSchema\n,\n\n  \nconnector\n:\n \ninvoiceConnector\n,\n\n\n}\n\n\n\nconst\n \nInvoice\n \n=\n \nnewModel\n(\nmodelConfig\n);\n \n// Invoice Model is a class\n\n\n\nNow you have all you want : A model, you can manipulate your data\n\n\nManipulate account\n\n\nFind one invoice after first january 2017\nconst\n \ninvoice\n \n=\n \nawait\n \nInvoice\n.\nquery\n()\n\n    \n.\ncreatedAt\n.\ngreatherThan\n(\nnew\n \nDate\n(\n2017-01-01\n))\n\n    \n.\nfindOne\n();\n\n\n\n\nCreate a new invoice\nWith attribute :\n\nconst\n \ninvoice\n \n=\n \nnew\n \nInvoice\n();\n\n\ninvoice\n.\ncreatedAt\n \n=\n \nDate\n.\nnow\n();\n\n\ninvoice\n.\namount\n \n=\n \n300\n;\n\n\ninvoice\n.\nsave\n();\n\n\nUsing constructor :\n\nconst\n \ninvoice\n \n=\n \nnew\n \nInvoice\n({\n\n    \ncreatedAt\n:\n \nDate\n.\nnow\n(),\n\n    \namount\n:\n \n300\n,\n\n\n});\n\n\ninvoice\n.\nsave\n();\n\n\nLoad an invoice per _id \n remove it from database\nconst\n \ninvoice\n \n=\n \nawait\n \nInvoice\n.\ngetById\n(\nObjectId\n(\n2088181818\n));\n\n\n\ninvoice\n.\nremove\n();\n\n\n\n\nFull example\n\n\nconst\n \nMongoClient\n \n=\n \nrequire\n(\nmongodb\n);\n\n\nconst\n \nilorm\n \n=\n \nrequire\n(\nilorm\n);\n\n\nconst\n \nIlormMongo\n \n=\n \nrequire\n(\nilorm-connector-mongodb\n);\n\n\n\nconst\n \n{\n \nSchema\n,\n \nnewModel\n,\n \n}\n \n=\n \nilorm\n;\n\n\n\n// Declare schema :\n\n\nconst\n \ninvoiceSchema\n \n=\n \nnew\n \nSchema\n({\n\n  \ncreatedAt\n:\n \nSchema\n.\ndate\n(),\n\n  \namount\n:\n \nSchema\n.\nnumber\n()\n\n\n});\n\n\n\n\n// Declare you use ilormMongo (init plugin part of the connector) :\n\n\nilorm\n.\nuse\n(\nIlormMongo\n);\n\n\n\n// Create a database :\n\n\nconst\n \nmongoClient\n \n=\n \nawait\n \nMongoClient\n.\nconnect\n(\nDB_URL\n);\n\n\nconst\n \ndatabase\n \n=\n \nawait\n \nmongoClient\n.\ndb\n(\nilorm\n);\n\n\n\n// Create your Connector class binded with your database :\n\n\nconst\n \nMongoConnector\n \n=\n \nIlormMongo\n.\nfromClient\n(\ndatabase\n);\n\n\n\n// Create an instance of your connector. It will save in the collection: accounts ;\n\n\nconst\n \ninvoiceConnector\n \n=\n \nnew\n \nMongoConnector\n({\n \ncollection\n:\n \ninvoices\n \n});\n\n\n\nconst\n \nmodelConfig\n \n=\n \n{\n\n  \nname\n:\n \ninvoices\n,\n \n// Optional, could be useful to know the model name\n\n  \nschema\n:\n \ninvoiceSchema\n,\n\n  \nconnector\n:\n \ninvoiceConnector\n,\n\n\n}\n\n\n\nconst\n \nInvoice\n \n=\n \nnewModel\n(\nmodelConfig\n);\n \n// Invoice Model is a class", 
            "title": "Quick start"
        }, 
        {
            "location": "/quick_start/#quick-start", 
            "text": "Ilorm are based on five core concepts : Connector, Model, Schema, SchemaField and Query.\n- Connectors are the definition which kind of database you use to store your data.\n- Model are class representing your data.\n- Schema define your model behavior (fields type)\n- SchemaField define the behavior of your data field.\n- Query is a powerful query builder tool to edit, delete, get data...", 
            "title": "Quick start"
        }, 
        {
            "location": "/quick_start/#install-ilorm", 
            "text": "First install ilorm : npm install ilorm  After you can install the mongo-connector : npm install ilorm-connector-mongodb  You can use another connector if you use different kind of database.", 
            "title": "Install ilorm"
        }, 
        {
            "location": "/quick_start/#define-a-schema", 
            "text": "To define your schema, just use the Schema class of ilorm const   {   Schema ,   }   =   require ( ilorm );  const   invoiceSchema   =   new   Schema ({ \n   createdAt :   Schema . date (), \n   amount :   Schema . number ()  });  \nWith this code, you have a basic schema with two properties :\n- createdAt which will be a date.\n- amount which will be a number.", 
            "title": "Define a schema"
        }, 
        {
            "location": "/quick_start/#prepare-your-connector", 
            "text": "const   MongoClient   =   require ( mongodb );  const   ilorm   =   require ( ilorm );  const   IlormMongo   =   require ( ilorm-connector-mongodb );  // Declare you use ilormMongo (init plugin part of the connector) :  ilorm . use ( IlormMongo );  // Create a database :  const   mongoClient   =   await   MongoClient . connect ( DB_URL );  const   database   =   await   mongoClient . db ( ilorm );  // Create your Connector class binded with your database :  const   MongoConnector   =   IlormMongo . fromClient ( database );  // Create an instance of your connector. It will save in the collection: accounts ;  const   invoiceConnector   =   new   MongoConnector ({   collection :   invoices   });  \nNow you have an invoiceConnector, it will save the binded model in the collection  invoices .", 
            "title": "Prepare your Connector"
        }, 
        {
            "location": "/quick_start/#create-your-model", 
            "text": "const   {   newModel ,   }   =   require ( ilorm );  const   modelConfig   =   { \n   name :   invoices ,   // Optional, could be useful to know the model name \n   schema :   invoiceSchema , \n   connector :   invoiceConnector ,  }  const   Invoice   =   newModel ( modelConfig );   // Invoice Model is a class  \nNow you have all you want : A model, you can manipulate your data", 
            "title": "Create your model"
        }, 
        {
            "location": "/quick_start/#manipulate-account", 
            "text": "Find one invoice after first january 2017 const   invoice   =   await   Invoice . query () \n     . createdAt . greatherThan ( new   Date ( 2017-01-01 )) \n     . findOne ();   Create a new invoice With attribute : const   invoice   =   new   Invoice ();  invoice . createdAt   =   Date . now ();  invoice . amount   =   300 ;  invoice . save ();  Using constructor : const   invoice   =   new   Invoice ({ \n     createdAt :   Date . now (), \n     amount :   300 ,  });  invoice . save ();  Load an invoice per _id   remove it from database const   invoice   =   await   Invoice . getById ( ObjectId ( 2088181818 ));  invoice . remove ();", 
            "title": "Manipulate account"
        }, 
        {
            "location": "/quick_start/#full-example", 
            "text": "const   MongoClient   =   require ( mongodb );  const   ilorm   =   require ( ilorm );  const   IlormMongo   =   require ( ilorm-connector-mongodb );  const   {   Schema ,   newModel ,   }   =   ilorm ;  // Declare schema :  const   invoiceSchema   =   new   Schema ({ \n   createdAt :   Schema . date (), \n   amount :   Schema . number ()  });  // Declare you use ilormMongo (init plugin part of the connector) :  ilorm . use ( IlormMongo );  // Create a database :  const   mongoClient   =   await   MongoClient . connect ( DB_URL );  const   database   =   await   mongoClient . db ( ilorm );  // Create your Connector class binded with your database :  const   MongoConnector   =   IlormMongo . fromClient ( database );  // Create an instance of your connector. It will save in the collection: accounts ;  const   invoiceConnector   =   new   MongoConnector ({   collection :   invoices   });  const   modelConfig   =   { \n   name :   invoices ,   // Optional, could be useful to know the model name \n   schema :   invoiceSchema , \n   connector :   invoiceConnector ,  }  const   Invoice   =   newModel ( modelConfig );   // Invoice Model is a class", 
            "title": "Full example"
        }, 
        {
            "location": "/api_public/", 
            "text": "API Public\n\n\nIlorm\n\n\nMain package documentation.\n\nconst\n \nilorm\n \n=\n \nrequire\n(\nilorm\n);\n\n\n\n\nExported class\n\n\nIlorm.Schema\n\n\nUse to declare your schema. \nSee Schema\n\n\nconst\n \n{\n\u00a0\nSchema\n \n}\n \n=\n \nrequire\n(\nilorm\n);\n\n\n\n\nExported functions\n\n\nIlorm.declareModel()\n\n\nDeclare model is used to change the Model associated with the given name. Could be used\nto define which Class will be instancied in each case.\n\n\ndeclareModel is already called in newModel, you need to invoke it, only if you overload\nthe resulting class of a newModel call.\n\nilorm\n.\ndeclareModel\n(\nModel\n);\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nModel\n\n\nModel\n\n\nThe Model to associate with the given name.\n\n\n\n\n\n\n\n\nExample of declareModel\nuserParams\n \n=\n \n{\n\n   \nname\n:\n \nusers\n,\n\n\n   \n// some other definition\n\n\n};\n\n\nconst\n \nBaseUser\n \n=\n \nnewModel\n(\nuserParams\n);\n\n\n\nconst\n \nUser\n \nextends\n \nBaseUser\n\n\n\n// Before declareModel ilorm associate \nusers\n with BaseUser\n\n\n\nilorm\n.\ndeclareModel\n(\nUser\n);\n\n\n\n// After ilorm associate \nusers\n with User, BaseUser was replaced\n\n\n\n// Now you could reference the Model User as users in your schema :\n\n\nconst\n \nfriendSchema\n \n=\n \nnew\n \nSchema\n({\n\n    \nuserA\n:\n \nSchema\n.\nreference\n(\nusers\n).\nrequired\n(),\n\n    \nuserB\n:\n \nSchema\n.\nreference\n(\nusers\n).\nrequired\n(),\n\n\n});\n\n\n\n\nIlorm.newModel()\n\n\nCreate a new Model class\n\nconst\n \n{\n \nnewModel\n \n}\n \n=\n \nrequire\n(\nilorm\n);\n\n\n\nconst\n \nModel\n \n=\n \nnewModel\n({\n \nname\n,\n \nschema\n,\n \nconnector\n \n})\n\n\n\nReturn a class \nModel\n you can use in your project to create new data or query.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nString, Symbol\n\n\nSymbol('model')\n\n\nThe unique name of the model, could be use to \nreference\n object.\n\n\n\n\n\n\nschema\n\n\nSchema\n\n\nnone\n\n\nSpecify the schema associated with the given model.\n\n\n\n\n\n\nconnector\n\n\nConnector\n\n\nnone\n\n\nSpecify the connector to use with the given model\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nYou can extends the created Model to add specific behavior of your code.\n\nclass\n \nYourModel\n \nextends\n \nnewModel\n(\nconf\n)\n \n{}\n\n\n\n\nExample of extends Model\nclass\n \nUser\n \nextends\n \nnewModel\n(\nuserConf\n)\n \n{\n\n    \nstatic\n \nqueryMale\n()\n \n{\n\n        \nreturn\n \nsuper\n.\nquery\n()\n\n            \n.\ngender\n.\nis\n(\nM\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nExample of newModel\nFull example of creating a UserModel\n\nconst\n \n{\n \nSchema\n,\n \nnewModel\n \n}\n \n=\n \nrequire\n(\nilorm\n);\n\n\nconst\n \nmongoConnector\n \n=\n \nrequire\n(\n./mongoConnector\n);\n\n\n\nconst\n \nuserSchema\n \n=\n \nnew\n \nSchema\n({\n\n  \nfirstName\n:\n \nSchema\n.\nstring\n().\nrequired\n(),\n\n  \nlastName\n:\n \nSchema\n.\nstring\n().\nrequired\n(),\n\n  \nbirthday\n:\n \nSchema\n.\ndate\n(),\n\n  \nweight\n:\n \nSchema\n.\nnumber\n(),\n\n  \nisLogged\n:\n \nSchema\n.\nboolean\n().\nrequired\n(),\n\n\n});\n\n\n\nconst\n \nUserModel\n \n=\n \nnewModel\n({\n\n\n    \nname\n:\n \nusers\n,\n\n\n    \nschema\n:\n \nuserSchema\n,\n\n\n    \nconnector\n:\n \nmongoConnector\n,\n\n\n});\n\n\nIlorm.use()\n\n\nModel\n\n\nModel could not be created directly. To access this API, you need to invoke the\n\nnewModel\n method from ilorm. And create your own child model.\n\n\n(static)\n Model.query()\n\n\nCreate a \nQuery\n instance targeting the current Model.\n\n\nconst\n \nquery\n \n=\n \nModel\n.\nquery\n();\n\n\n\nReturn a query instance linked with the current Model.\n\n\nExample of query\nUserModel is a Model with a numberField : \nweight\n.\n\nconst\n \nuser\n \n=\n \nasync\n \nUserModel\n.\nquery\n()\n\n\n    \n.\nweight\n.\nmin\n(\n80\n)\n\n    \n.\nfindOne\n();\n\n\n(static)\n(async)\n Model.getById()\n\n\nGet an instance of the model by it's Id.\n\nconst\n \nmodelInstance\n \n=\n \nawait\n \nModel\n.\ngetById\n(\nid\n);\n\n\n\nReturn the instance associated with the given id.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nid\n\n\nMixing\n\n\n\n\nThe id of the instance to get.\n\n\n\n\n\n\n\n\n(async)\n Model.save()\n\n\nSave the current instance into the database.\n- If the instance exists, it will make an update with the updated field only.\n- If the instance does not exists. It will create the instance into the database.\n\n\nawait\n \nmodelInstance\n.\nsave\n();\n\n\n\n\n\n(async)\n Model.remove()\n\n\nRemove the current instance from the database.\n\n\nawait\n \nmodelInstance\n.\nremove\n();\n\n\n\n\n\nQuery\n\n\nQuery is a class which could be only instancied with the\n\nquery static method of model\n.\n\n\nQuery is a query builder used to run operation on your database. Like find an instance\nor update multiple instance.\n\n\nQuery work directly in function of your schema. Every field declared on your schema\nare defined as attribute of the Query. You can split your query into two things :\n- The query building part : You choose what your query will do.\n- The query run part : You choose the operation to do and execute the query.\n\n\nQuery building\n\n\nQuery building are in function of the field of your schema. All method are children of\nattribute defined in your schema.\n\n\n\n\nLittle example\n\n\nWith this kind of schema :\n\nconst\n \ninvoice\n \n=\n \nnew\n \nSchema\n({\n\n    \ndate\n:\n \nSchema\n.\ndate\n().\nrequired\n(),\n\n    \namount\n:\n \nSchema\n.\nnumber\n().\nrequired\n(),\n\n\n})\n\n\n\n\nYou could use this kind of query :\n\nconst\n \ninvoice\n \n=\n \nawait\n \nInvoices\n.\nquery\n()\n\n    \n.\namount\n.\ngreaterThan\n(\n100\n)\n \n// amount is here in function of your schema\n\n    \n.\nfindOne\n();\n    \n\n\n\n\n\nQuery.\n[field]\n.is()\n\n\nCheck if the \n[field]\n is equal of the specified value.\n\nQuery\n.\nfield\n.\nis\n(\nvalue\n);\n\n\n\nReturns a query to chain call.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nMixing\n\n\nThe field need to be equal of this value.\n\n\n\n\n\n\n\n\nQuery.\n[field]\n.isNot()\n\n\nCheck if the \n[field]\n is not equal of the specified value.\n\nQuery\n.\nfield\n.\nisNot\n(\nvalue\n);\n\n\n\nReturns a query to chain call.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nMixing\n\n\nThe field need to be different of this value.\n\n\n\n\n\n\n\n\nQuery.\n[field]\n.isIn()\n\n\nCheck if the \n[field]\n is a member of the parameter array\n\nQuery\n.\nfield\n.\nisIn\n(\narrayOfValue\n);\n\n\n\nReturns a query to chain call.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\narrayOfValue\n\n\nArray.\nMixing>\n\n\nThe field need to be equal at one array element.\n\n\n\n\n\n\n\n\nQuery.\n[field]\n.isNotIn()\n\n\nCheck if the \n[field]\n is not one of the array value.\n\nQuery\n.\nfield\n.\nisNotIn\n(\narrayOfValue\n);\n\n\n\nReturns a query to chain call.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\narrayOfValue\n\n\nArray.\nMixing>\n\n\nThe field need to be different of each array element.\n\n\n\n\n\n\n\n\nQuery.\n[field]\n.greaterThan()\n\n\nCheck if the \n[field]\n is greater than the specified value.\n\nQuery\n.\nfield\n.\ngreaterThan\n(\nvalue\n);\n\n\n\nReturns a query to chain call.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nMixing\n\n\nThe field need to be greater than value.\n\n\n\n\n\n\n\n\n\n\nInfo\n\n\nOnly work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField).\n\n\n\n\nQuery.\n[field]\n.lowerThan()\n\n\nCheck if the \n[field]\n is lower than the specified value.\n\nQuery\n.\nfield\n.\nlowerThan\n(\nvalue\n);\n\n\n\nReturns a query to chain call.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nMixing\n\n\nThe field need to be lower than value.\n\n\n\n\n\n\n\n\n\n\nInfo\n\n\nOnly work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField).\n\n\n\n\nQuery.\n[field]\n.greaterOrEqualThan()\n\n\nCheck if the \n[field]\n is equal or greater than the \nspecified value.\n\nQuery\n.\nfield\n.\ngreaterOrEqualThan\n(\nvalue\n);\n\n\n\nReturns a query to chain call.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nMixing\n\n\nThe field need to be equal or grater than value.\n\n\n\n\n\n\n\n\n\n\nInfo\n\n\nOnly work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField).\n\n\n\n\nQuery.\n[field]\n.lowerOrEqualThan()\n\n\nCheck if the \n[field]\n is equal or lower than\nspecified value.\n\nQuery\n.\nfield\n.\nlowerOrEqualThan\n(\nvalue\n);\n\n\n\nReturns a query to chain call.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nMixing\n\n\nThe field need to be equal or lower than value.\n\n\n\n\n\n\n\n\n\n\nInfo\n\n\nOnly work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField).\n\n\n\n\nQuery.\n[field]\n.between()\n\n\nCheck if the \n[field]\n is between min and max.\n\nQuery\n.\nfield\n.\nbetween\n(\nmin\n,\n \nmax\n);\n\n\n\nReturns a query to chain call.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmin\n\n\nMixing\n\n\nThe field need to be greater than min.\n\n\n\n\n\n\nmax\n\n\nMixing\n\n\nThe field need to be lower than max.\n\n\n\n\n\n\n\n\n\n\nInfo\n\n\nOnly work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField).\n\n\n\n\nQuery running\n\n\n(async)\n Query.findOne()\n\n\nExecute the query, and returns one element which match it.\n\n\nconst\n \ninstance\n \n=\n \nawait\n \nquery\n.\nfindOne\n();\n\n\n\nReturn one instance which match the query.\n\n\n(async)\n Query.find()\n\n\nExecute the query, and returns one array containing all elements which match the query.\n\n\nconst\n \narrayOfInstances\n \n=\n \nawait\n \nquery\n.\nfind\n();\n\n\n\nReturn all instance which match the query.\n\n\n(async)\n Query.stream()\n\n\nExecute the query, and returns the stream of all elements matching the query\n\n\nconst\n \nstreamOfInstances\n \n=\n \nawait\n \nquery\n.\nstream\n();\n\n\n\nReturn a stream containing all elements matching the query.\n\n\n(async)\n Query.count()\n\n\nExecute the query, and return how many item match the query.\n\n\nconst\n \nnumberOfInstance\n \n=\n \nawait\n \nquery\n.\ncount\n();\n\n\n\nReturn the number of instance which match the query.\n\n\n(async)\n Query.updateOne()\n\n\n(async)\n Query.update()\n\n\n(async)\n Query.removeOne()\n\n\n(async)\n Query.remove()\n\n\nSchema\n\n\nSchema define how your data are stored.\n\n\nExample of schema\nBasic example of what a schema \"user\" could look like :\n\nconst\n \n{\n \nSchema\n \n}\n \n=\n \nrequire\n(\nilorm\n);\n\n\n\nconst\n \nuserSchema\n \n=\n \nnew\n \nSchema\n({\n\n  \nfirstName\n:\n \nSchema\n.\nstring\n().\nrequired\n(),\n\n  \nlastName\n:\n \nSchema\n.\nstring\n().\nrequired\n(),\n\n  \nbirthday\n:\n \nSchema\n.\ndate\n(),\n\n  \nweight\n:\n \nSchema\n.\nnumber\n(),\n\n  \nisLogged\n:\n \nSchema\n.\nboolean\n().\nrequired\n(),\n\n\n});\n\n\nconstructor Schema()\n\n\nInstantiate a new schema object.\n\n\nnew\n \nSchema\n(\nschemaDefinition\n);\n\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nschemaDefinition\n\n\nObject\n\n\nAn object ; \n{ key: SchemaField }\n where every key will be the name of the field in the model, and SchemaField the definition of the field.\n\n\n\n\n\n\n\n\n(static)\n Schema.boolean()\n\n\nFactory to create a \nBoolean\n.\n\nSchema\n.\nboolean\n()\n\n\n\n\nReturn a \nBoolean instance\n.\n\n\nExample of boolean\nBasic example of what a schema \"user\" could look like :\n\nconst\n \n{\n \nSchema\n \n}\n \n=\n \nrequire\n(\nilorm\n);\n\n\n\nconst\n \nuserSchema\n \n=\n \nnew\n \nSchema\n({\n\n  \nfirstName\n:\n \nSchema\n.\nstring\n().\nrequired\n(),\n\n  \nlastName\n:\n \nSchema\n.\nstring\n().\nrequired\n(),\n\n  \nbirthday\n:\n \nSchema\n.\ndate\n(),\n\n  \nweight\n:\n \nSchema\n.\nnumber\n(),\n\n\n  \nisLogged\n:\n \nSchema\n.\nboolean\n().\nrequired\n(),\n\n\n});\n\n\n(static)\n Schema.date()\n\n\nFactory to create a \nDate\n.\n\nSchema\n.\ndate\n()\n\n\n\n\nReturn a \nDate instance\n.\n\n\nExample of date\nBasic example of what a schema \"user\" could look like :\n\nconst\n \n{\n \nSchema\n \n}\n \n=\n \nrequire\n(\nilorm\n);\n\n\n\nconst\n \nuserSchema\n \n=\n \nnew\n \nSchema\n({\n\n  \nfirstName\n:\n \nSchema\n.\nstring\n().\nrequired\n(),\n\n  \nlastName\n:\n \nSchema\n.\nstring\n().\nrequired\n(),\n\n\n  \nbirthday\n:\n \nSchema\n.\ndate\n(),\n\n\n  \nweight\n:\n \nSchema\n.\nnumber\n(),\n\n  \nisLogged\n:\n \nSchema\n.\nboolean\n().\nrequired\n(),\n\n\n});\n\n\n(static)\n Schema.number()\n\n\nFactory to create a \nNumber\n.\n\nSchema\n.\nnumber\n()\n\n\n\n\nReturn a \nNumber instance\n.\n\n\nExample of number\nBasic example of what a schema \"user\" could look like :\n\nconst\n \n{\n \nSchema\n \n}\n \n=\n \nrequire\n(\nilorm\n);\n\n\n\nconst\n \nuserSchema\n \n=\n \nnew\n \nSchema\n({\n\n  \nfirstName\n:\n \nSchema\n.\nstring\n().\nrequired\n(),\n\n  \nlastName\n:\n \nSchema\n.\nstring\n().\nrequired\n(),\n\n  \nbirthday\n:\n \nSchema\n.\ndate\n(),\n\n\n  \nweight\n:\n \nSchema\n.\nnumber\n(),\n\n\n  \nisLogged\n:\n \nSchema\n.\nboolean\n().\nrequired\n(),\n\n\n});\n\n\n(static)\n Schema.reference()\n\n\nFactory to create a \nReference\n.\n\nSchema\n.\nreference\n(\nmodelName\n)\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmodelName\n\n\nString\n\n\nSpecify which model is linked with the given reference.\n\n\n\n\n\n\n\n\nReturn a \nReference instance\n.\n\n\nExample of reference\nBasic example of what a schema \"user\" could look like :\n\nconst\n \n{\n \nSchema\n \n}\n \n=\n \nrequire\n(\nilorm\n);\n\n\n\nconst\n \nuserSchema\n \n=\n \nnew\n \nSchema\n({\n\n  \nfirstName\n:\n \nSchema\n.\nstring\n().\nrequired\n(),\n\n  \nlastName\n:\n \nSchema\n.\nstring\n().\nrequired\n(),\n\n\n  \nfather\n:\n \nSchema\n.\nreference\n(\nusers\n),\n\n\n});\n\n\n(static)\n Schema.string()\n\n\nFactory to create a \nString\n.\n\nSchema\n.\nstring\n()\n\n\n\n\nReturn a \nString instance\n.\n\n\nExample of string\nBasic example of what a schema \"user\" could look like :\n\nconst\n \n{\n \nSchema\n \n}\n \n=\n \nrequire\n(\nilorm\n);\n\n\n\nconst\n \nuserSchema\n \n=\n \nnew\n \nSchema\n({\n\n\n  \nfirstName\n:\n \nSchema\n.\nstring\n().\nrequired\n(),\n\n\n  \nlastName\n:\n \nSchema\n.\nstring\n().\nrequired\n(),\n\n\n  \nbirthday\n:\n \nSchema\n.\ndate\n(),\n\n  \nweight\n:\n \nSchema\n.\nnumber\n(),\n\n  \nisLogged\n:\n \nSchema\n.\nboolean\n().\nrequired\n(),\n\n\n});\n\n\nSchemaField\n\n\nSchemaField is a class used to define the behavior of your fields. Every field type\nare children of the SchemaField class. The SchemaField class is an abstract class.\nYou can create your own custom field by inheritance with SchemaField.\n\n\nSchemaField.default()\n\n\nSpecify the default value of the field, if no value are provided.\n\nconst\n \nfield\n \n=\n \nnew\n \nSchemaField\n();\n\n\n\nfield\n.\ndefault\n(\nvalue\n);\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\n*\n\n\nDefine the default value of the field.\n\n\n\n\n\n\n\n\nExample of default\nBasic example of what a schema \"user\" could look like :\n\nconst\n \n{\n \nSchema\n \n}\n \n=\n \nrequire\n(\nilorm\n);\n\n\n\nconst\n \nuserSchema\n \n=\n \nnew\n \nSchema\n({\n\n  \nfirstName\n:\n \nSchema\n.\nstring\n().\nrequired\n(),\n\n  \nlastName\n:\n \nSchema\n.\nstring\n().\nrequired\n(),\n\n  \nbirthday\n:\n \nSchema\n.\ndate\n(),\n\n  \nweight\n:\n \nSchema\n.\nnumber\n(),\n\n\n  \nisLogged\n:\n \nSchema\n.\nboolean\n().\ndefault\n(\ntrue\n).\nrequired\n(),\n\n\n});\n\n\nSchemaField.required()\n\n\nSpecify the field as required. A required field is mandatory to be save.\nAn instance without mandatory field throw error.\n\nconst\n \nfield\n \n=\n \nnew\n \nSchemaField\n();\n\n\n\nfield\n.\nrequired\n(\nisRequired\n \n=\n \ntrue\n);\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nisRequired\n\n\nBoolean\n\n\ntrue\n\n\nDefine the field as required (or not).\n\n\n\n\n\n\n\n\nPer default, the field is always not required. By calling this method, without parameter\nyou change the required status.\n\n\nExample of required\nBasic example of what a schema \"user\" could look like :\n\nconst\n \n{\n \nSchema\n \n}\n \n=\n \nrequire\n(\nilorm\n);\n\n\n\nconst\n \nuserSchema\n \n=\n \nnew\n \nSchema\n({\n\n\n  \nfirstName\n:\n \nSchema\n.\nstring\n().\nrequired\n(),\n\n\n  \nlastName\n:\n \nSchema\n.\nstring\n().\nrequired\n(),\n\n\n  \nbirthday\n:\n \nSchema\n.\ndate\n(),\n\n  \nweight\n:\n \nSchema\n.\nnumber\n(),\n\n\n  \nisLogged\n:\n \nSchema\n.\nboolean\n().\ndefault\n(\ntrue\n).\nrequired\n(),\n\n\n});\n\n\nSchemaField/Boolean\n\n\nDefine the field as boolean.\n\n\nSchemaField/Date\n\n\nDefine the field as date.\n\n\nSchemaField/Number\n\n\nDefine the field as number.\n\n\nSchemaField/Reference\n\n\nDefine the field as reference.\n\n\nSchemaField/String\n\n\nDefine the field as string.", 
            "title": "API"
        }, 
        {
            "location": "/api_public/#api-public", 
            "text": "", 
            "title": "API Public"
        }, 
        {
            "location": "/api_public/#ilorm", 
            "text": "Main package documentation. const   ilorm   =   require ( ilorm );", 
            "title": "Ilorm"
        }, 
        {
            "location": "/api_public/#exported-class", 
            "text": "", 
            "title": "Exported class"
        }, 
        {
            "location": "/api_public/#ilormschema", 
            "text": "Use to declare your schema.  See Schema  const   { \u00a0 Schema   }   =   require ( ilorm );", 
            "title": "Ilorm.Schema"
        }, 
        {
            "location": "/api_public/#exported-functions", 
            "text": "", 
            "title": "Exported functions"
        }, 
        {
            "location": "/api_public/#ilormdeclaremodel", 
            "text": "Declare model is used to change the Model associated with the given name. Could be used\nto define which Class will be instancied in each case.  declareModel is already called in newModel, you need to invoke it, only if you overload\nthe resulting class of a newModel call. ilorm . declareModel ( Model );      Parameter  Type  Description      Model  Model  The Model to associate with the given name.     Example of declareModel userParams   =   { \n    name :   users ,      // some other definition  };  const   BaseUser   =   newModel ( userParams );  const   User   extends   BaseUser  // Before declareModel ilorm associate  users  with BaseUser  ilorm . declareModel ( User );  // After ilorm associate  users  with User, BaseUser was replaced  // Now you could reference the Model User as users in your schema :  const   friendSchema   =   new   Schema ({ \n     userA :   Schema . reference ( users ). required (), \n     userB :   Schema . reference ( users ). required (),  });", 
            "title": "Ilorm.declareModel()"
        }, 
        {
            "location": "/api_public/#ilormnewmodel", 
            "text": "Create a new Model class const   {   newModel   }   =   require ( ilorm );  const   Model   =   newModel ({   name ,   schema ,   connector   })  \nReturn a class  Model  you can use in your project to create new data or query.     Parameter  Type  Default  Description      name  String, Symbol  Symbol('model')  The unique name of the model, could be use to  reference  object.    schema  Schema  none  Specify the schema associated with the given model.    connector  Connector  none  Specify the connector to use with the given model      Tip  You can extends the created Model to add specific behavior of your code. class   YourModel   extends   newModel ( conf )   {}   Example of extends Model class   User   extends   newModel ( userConf )   { \n     static   queryMale ()   { \n         return   super . query () \n             . gender . is ( M ); \n     }  }    Example of newModel Full example of creating a UserModel const   {   Schema ,   newModel   }   =   require ( ilorm );  const   mongoConnector   =   require ( ./mongoConnector );  const   userSchema   =   new   Schema ({ \n   firstName :   Schema . string (). required (), \n   lastName :   Schema . string (). required (), \n   birthday :   Schema . date (), \n   weight :   Schema . number (), \n   isLogged :   Schema . boolean (). required (),  });  const   UserModel   =   newModel ({       name :   users ,       schema :   userSchema ,       connector :   mongoConnector ,  });", 
            "title": "Ilorm.newModel()"
        }, 
        {
            "location": "/api_public/#ilormuse", 
            "text": "", 
            "title": "Ilorm.use()"
        }, 
        {
            "location": "/api_public/#model", 
            "text": "Model could not be created directly. To access this API, you need to invoke the newModel  method from ilorm. And create your own child model.", 
            "title": "Model"
        }, 
        {
            "location": "/api_public/#static-modelquery", 
            "text": "Create a  Query  instance targeting the current Model.  const   query   =   Model . query ();  \nReturn a query instance linked with the current Model.  Example of query UserModel is a Model with a numberField :  weight . const   user   =   async   UserModel . query ()       . weight . min ( 80 ) \n     . findOne ();", 
            "title": "(static) Model.query()"
        }, 
        {
            "location": "/api_public/#staticasync-modelgetbyid", 
            "text": "Get an instance of the model by it's Id. const   modelInstance   =   await   Model . getById ( id );  \nReturn the instance associated with the given id.     Parameter  Type  Default  Description      id  Mixing   The id of the instance to get.", 
            "title": "(static)(async) Model.getById()"
        }, 
        {
            "location": "/api_public/#async-modelsave", 
            "text": "Save the current instance into the database.\n- If the instance exists, it will make an update with the updated field only.\n- If the instance does not exists. It will create the instance into the database.  await   modelInstance . save ();", 
            "title": "(async) Model.save()"
        }, 
        {
            "location": "/api_public/#async-modelremove", 
            "text": "Remove the current instance from the database.  await   modelInstance . remove ();", 
            "title": "(async) Model.remove()"
        }, 
        {
            "location": "/api_public/#query", 
            "text": "Query is a class which could be only instancied with the query static method of model .  Query is a query builder used to run operation on your database. Like find an instance\nor update multiple instance.  Query work directly in function of your schema. Every field declared on your schema\nare defined as attribute of the Query. You can split your query into two things :\n- The query building part : You choose what your query will do.\n- The query run part : You choose the operation to do and execute the query.", 
            "title": "Query"
        }, 
        {
            "location": "/api_public/#query-building", 
            "text": "Query building are in function of the field of your schema. All method are children of\nattribute defined in your schema.   Little example  With this kind of schema : const   invoice   =   new   Schema ({ \n     date :   Schema . date (). required (), \n     amount :   Schema . number (). required (),  })   You could use this kind of query : const   invoice   =   await   Invoices . query () \n     . amount . greaterThan ( 100 )   // amount is here in function of your schema \n     . findOne ();", 
            "title": "Query building"
        }, 
        {
            "location": "/api_public/#queryfieldis", 
            "text": "Check if the  [field]  is equal of the specified value. Query . field . is ( value );  \nReturns a query to chain call.     Parameter  Type  Description      value  Mixing  The field need to be equal of this value.", 
            "title": "Query.[field].is()"
        }, 
        {
            "location": "/api_public/#queryfieldisnot", 
            "text": "Check if the  [field]  is not equal of the specified value. Query . field . isNot ( value );  \nReturns a query to chain call.     Parameter  Type  Description      value  Mixing  The field need to be different of this value.", 
            "title": "Query.[field].isNot()"
        }, 
        {
            "location": "/api_public/#queryfieldisin", 
            "text": "Check if the  [field]  is a member of the parameter array Query . field . isIn ( arrayOfValue );  \nReturns a query to chain call.     Parameter  Type  Description      arrayOfValue  Array. Mixing>  The field need to be equal at one array element.", 
            "title": "Query.[field].isIn()"
        }, 
        {
            "location": "/api_public/#queryfieldisnotin", 
            "text": "Check if the  [field]  is not one of the array value. Query . field . isNotIn ( arrayOfValue );  \nReturns a query to chain call.     Parameter  Type  Description      arrayOfValue  Array. Mixing>  The field need to be different of each array element.", 
            "title": "Query.[field].isNotIn()"
        }, 
        {
            "location": "/api_public/#queryfieldgreaterthan", 
            "text": "Check if the  [field]  is greater than the specified value. Query . field . greaterThan ( value );  \nReturns a query to chain call.     Parameter  Type  Description      value  Mixing  The field need to be greater than value.      Info  Only work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField).", 
            "title": "Query.[field].greaterThan()"
        }, 
        {
            "location": "/api_public/#queryfieldlowerthan", 
            "text": "Check if the  [field]  is lower than the specified value. Query . field . lowerThan ( value );  \nReturns a query to chain call.     Parameter  Type  Description      value  Mixing  The field need to be lower than value.      Info  Only work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField).", 
            "title": "Query.[field].lowerThan()"
        }, 
        {
            "location": "/api_public/#queryfieldgreaterorequalthan", 
            "text": "Check if the  [field]  is equal or greater than the \nspecified value. Query . field . greaterOrEqualThan ( value );  \nReturns a query to chain call.     Parameter  Type  Description      value  Mixing  The field need to be equal or grater than value.      Info  Only work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField).", 
            "title": "Query.[field].greaterOrEqualThan()"
        }, 
        {
            "location": "/api_public/#queryfieldlowerorequalthan", 
            "text": "Check if the  [field]  is equal or lower than\nspecified value. Query . field . lowerOrEqualThan ( value );  \nReturns a query to chain call.     Parameter  Type  Description      value  Mixing  The field need to be equal or lower than value.      Info  Only work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField).", 
            "title": "Query.[field].lowerOrEqualThan()"
        }, 
        {
            "location": "/api_public/#queryfieldbetween", 
            "text": "Check if the  [field]  is between min and max. Query . field . between ( min ,   max );  \nReturns a query to chain call.     Parameter  Type  Description      min  Mixing  The field need to be greater than min.    max  Mixing  The field need to be lower than max.      Info  Only work with SchemaField/Number or SchemaField/Date (or with some plugin SchemaField).", 
            "title": "Query.[field].between()"
        }, 
        {
            "location": "/api_public/#query-running", 
            "text": "", 
            "title": "Query running"
        }, 
        {
            "location": "/api_public/#async-queryfindone", 
            "text": "Execute the query, and returns one element which match it.  const   instance   =   await   query . findOne ();  \nReturn one instance which match the query.", 
            "title": "(async) Query.findOne()"
        }, 
        {
            "location": "/api_public/#async-queryfind", 
            "text": "Execute the query, and returns one array containing all elements which match the query.  const   arrayOfInstances   =   await   query . find ();  \nReturn all instance which match the query.", 
            "title": "(async) Query.find()"
        }, 
        {
            "location": "/api_public/#async-querystream", 
            "text": "Execute the query, and returns the stream of all elements matching the query  const   streamOfInstances   =   await   query . stream ();  \nReturn a stream containing all elements matching the query.", 
            "title": "(async) Query.stream()"
        }, 
        {
            "location": "/api_public/#async-querycount", 
            "text": "Execute the query, and return how many item match the query.  const   numberOfInstance   =   await   query . count ();  \nReturn the number of instance which match the query.", 
            "title": "(async) Query.count()"
        }, 
        {
            "location": "/api_public/#async-queryupdateone", 
            "text": "", 
            "title": "(async) Query.updateOne()"
        }, 
        {
            "location": "/api_public/#async-queryupdate", 
            "text": "", 
            "title": "(async) Query.update()"
        }, 
        {
            "location": "/api_public/#async-queryremoveone", 
            "text": "", 
            "title": "(async) Query.removeOne()"
        }, 
        {
            "location": "/api_public/#async-queryremove", 
            "text": "", 
            "title": "(async) Query.remove()"
        }, 
        {
            "location": "/api_public/#schema", 
            "text": "Schema define how your data are stored.  Example of schema Basic example of what a schema \"user\" could look like : const   {   Schema   }   =   require ( ilorm );  const   userSchema   =   new   Schema ({ \n   firstName :   Schema . string (). required (), \n   lastName :   Schema . string (). required (), \n   birthday :   Schema . date (), \n   weight :   Schema . number (), \n   isLogged :   Schema . boolean (). required (),  });", 
            "title": "Schema"
        }, 
        {
            "location": "/api_public/#constructor-schema", 
            "text": "Instantiate a new schema object.  new   Schema ( schemaDefinition );      Parameter  Type  Description      schemaDefinition  Object  An object ;  { key: SchemaField }  where every key will be the name of the field in the model, and SchemaField the definition of the field.", 
            "title": "constructor Schema()"
        }, 
        {
            "location": "/api_public/#static-schemaboolean", 
            "text": "Factory to create a  Boolean . Schema . boolean ()   Return a  Boolean instance .  Example of boolean Basic example of what a schema \"user\" could look like : const   {   Schema   }   =   require ( ilorm );  const   userSchema   =   new   Schema ({ \n   firstName :   Schema . string (). required (), \n   lastName :   Schema . string (). required (), \n   birthday :   Schema . date (), \n   weight :   Schema . number (),     isLogged :   Schema . boolean (). required (),  });", 
            "title": "(static) Schema.boolean()"
        }, 
        {
            "location": "/api_public/#static-schemadate", 
            "text": "Factory to create a  Date . Schema . date ()   Return a  Date instance .  Example of date Basic example of what a schema \"user\" could look like : const   {   Schema   }   =   require ( ilorm );  const   userSchema   =   new   Schema ({ \n   firstName :   Schema . string (). required (), \n   lastName :   Schema . string (). required (),     birthday :   Schema . date (),     weight :   Schema . number (), \n   isLogged :   Schema . boolean (). required (),  });", 
            "title": "(static) Schema.date()"
        }, 
        {
            "location": "/api_public/#static-schemanumber", 
            "text": "Factory to create a  Number . Schema . number ()   Return a  Number instance .  Example of number Basic example of what a schema \"user\" could look like : const   {   Schema   }   =   require ( ilorm );  const   userSchema   =   new   Schema ({ \n   firstName :   Schema . string (). required (), \n   lastName :   Schema . string (). required (), \n   birthday :   Schema . date (),     weight :   Schema . number (),     isLogged :   Schema . boolean (). required (),  });", 
            "title": "(static) Schema.number()"
        }, 
        {
            "location": "/api_public/#static-schemareference", 
            "text": "Factory to create a  Reference . Schema . reference ( modelName )      Parameter  Type  Description      modelName  String  Specify which model is linked with the given reference.     Return a  Reference instance .  Example of reference Basic example of what a schema \"user\" could look like : const   {   Schema   }   =   require ( ilorm );  const   userSchema   =   new   Schema ({ \n   firstName :   Schema . string (). required (), \n   lastName :   Schema . string (). required (),     father :   Schema . reference ( users ),  });", 
            "title": "(static) Schema.reference()"
        }, 
        {
            "location": "/api_public/#static-schemastring", 
            "text": "Factory to create a  String . Schema . string ()   Return a  String instance .  Example of string Basic example of what a schema \"user\" could look like : const   {   Schema   }   =   require ( ilorm );  const   userSchema   =   new   Schema ({     firstName :   Schema . string (). required (),     lastName :   Schema . string (). required (),     birthday :   Schema . date (), \n   weight :   Schema . number (), \n   isLogged :   Schema . boolean (). required (),  });", 
            "title": "(static) Schema.string()"
        }, 
        {
            "location": "/api_public/#schemafield", 
            "text": "SchemaField is a class used to define the behavior of your fields. Every field type\nare children of the SchemaField class. The SchemaField class is an abstract class.\nYou can create your own custom field by inheritance with SchemaField.", 
            "title": "SchemaField"
        }, 
        {
            "location": "/api_public/#schemafielddefault", 
            "text": "Specify the default value of the field, if no value are provided. const   field   =   new   SchemaField ();  field . default ( value );      Parameter  Type  Description      value  *  Define the default value of the field.     Example of default Basic example of what a schema \"user\" could look like : const   {   Schema   }   =   require ( ilorm );  const   userSchema   =   new   Schema ({ \n   firstName :   Schema . string (). required (), \n   lastName :   Schema . string (). required (), \n   birthday :   Schema . date (), \n   weight :   Schema . number (),     isLogged :   Schema . boolean (). default ( true ). required (),  });", 
            "title": "SchemaField.default()"
        }, 
        {
            "location": "/api_public/#schemafieldrequired", 
            "text": "Specify the field as required. A required field is mandatory to be save.\nAn instance without mandatory field throw error. const   field   =   new   SchemaField ();  field . required ( isRequired   =   true );      Parameter  Type  Default  Description      isRequired  Boolean  true  Define the field as required (or not).     Per default, the field is always not required. By calling this method, without parameter\nyou change the required status.  Example of required Basic example of what a schema \"user\" could look like : const   {   Schema   }   =   require ( ilorm );  const   userSchema   =   new   Schema ({     firstName :   Schema . string (). required (),     lastName :   Schema . string (). required (),     birthday :   Schema . date (), \n   weight :   Schema . number (),     isLogged :   Schema . boolean (). default ( true ). required (),  });", 
            "title": "SchemaField.required()"
        }, 
        {
            "location": "/api_public/#schemafieldboolean", 
            "text": "Define the field as boolean.", 
            "title": "SchemaField/Boolean"
        }, 
        {
            "location": "/api_public/#schemafielddate", 
            "text": "Define the field as date.", 
            "title": "SchemaField/Date"
        }, 
        {
            "location": "/api_public/#schemafieldnumber", 
            "text": "Define the field as number.", 
            "title": "SchemaField/Number"
        }, 
        {
            "location": "/api_public/#schemafieldreference", 
            "text": "Define the field as reference.", 
            "title": "SchemaField/Reference"
        }, 
        {
            "location": "/api_public/#schemafieldstring", 
            "text": "Define the field as string.", 
            "title": "SchemaField/String"
        }, 
        {
            "location": "/advanced/create_connector/", 
            "text": "Create a connector\n\n\nThe connector class\n\n\nBasics\n\n\nTo create a connector, you need to implement a class Connector.\n\n\nThe class Connector is always linked with a database\nThe instance of the class is linked with a table, a collection or a subset of data.\n\n\nExample :\n\n\n\n\n\n\nOn a SQL database\n\n\n\n\n\n\nThe class is linked with the full database\n\n\n\n\n\n\nAn instance of the class is linked with a table\n\n\n\n\n\n\n\n\n\n\nOn a MongoDB database\n\n\n\n\n\n\nThe class linked with the full database\n\n\n\n\n\n\nAn instance of the class is linked with a collection\n\n\n\n\n\n\n\n\n\n\nMandatory operation\n\n\nThe class need to implement mandatory operation to be fully functional.\nThe operations are divided into :\n\n\n\n\n\n\nDatabase related : Update, Find, Create, Remove data\n\n\n\n\n\n\nConnector factory : The connector instantiate his own Query class or Model class to overwrite\nbasic behavior.\n\n\n\n\n\n\nDatabase related\n\n\nIlorm query\n\n\nThe majority of database related operation receive a Query instance as parameter.\nYou need to use this query instance to create the same query in the database language\nto do it. The query have some useful method : queryBuilder and updateBuilder.\n\n\nqueryBuilder\n\n\nquery.queryBuilder is use to restrict your query. You will put as parameter of queryBuilder\na set of handler. Each handler should be called back (in function of the query).\n\nquery\n.\nqueryBuilder\n({\n\n  \n// On option will be called if skip \n limit was put :\n\n  \nonOption\n:\n \n(\nskip\n,\n \nlimit\n)\n \n=\n \n{},\n\n\n  \n// If an or operator is used on the query, this handler will be called\n\n  \n// The parameter is multiple query instance (each or branch)\n\n  \nonOr\n:\n \narrayOfQuery\n \n=\n \n{},\n\n\n  \n// If one or more field are select, this handler will be called\n\n  \n// You need to restrict result only to the specified field\n\n  \nonSelect\n:\n \n({\n \nfield\n,\n \n})\n \n=\n \n{},\n\n\n  \n// Called (in order), to set the order of the result.\n\n  \n// Key is the target sorting key\n\n  \n// behavior precise if it\ns ascending or descending sorting\n\n  \nonSort\n:\n \n({\n \nkey\n,\n \nbehavior\n,\n \n})\n \n=\n \n{},\n\n\n  \n// Called per each query operation\n\n  \n// Key is the target key\n\n  \n// Operation is EQUAL, NOT_EQUAL...\n\n  \n// Value is the value applied to the operation\n\n  \nonOperator\n:\n \n({\n \nkey\n,\n \noperation\n,\n \nvalue\n,\n \n})\n \n=\n \n{}\n\n\n});\n\n\n\nBehavior and operation are equal to specific constants. The constants can be found in\n\nilorm-constants\n in the QUERY constants :\n\nconst\n \n{\n \nQUERY\n,\n \n}\n \n=\n \nrequire\n(\nilorm-constants\n);\n\n\n\n// Possible value of operation on the onOperator handler :\n\n\nconst\n \n{\n \nOPERATIONS\n \n}\n \n=\n \nQUERY\n;\n\n\nOPERATION\n.\nIS\n \n// equal (===)\n\n\nOPERATION\n.\nIS_NOT\n \n// Not equal (!==)\n\n\nOPERATION\n.\nIS_IN\n \n// The value is in the specified array of possibility\n\n\nOPERATION\n.\nIS_NOT_IN\n \n// The value is not in the specified array of possibility\n\n\nOPERATION\n.\nGREATHER_THAN\n \n// Superior of the value\n\n\nOPERATION\n.\nLOWER_THAN\n \n// Inferior of the value\n\n\nOPERATION_GREATHER_OR_EQUAL_THAN\n \n// Superior or equal of the value\n\n\nOPERATION\n.\nLOWER_OR_EQUAL_THAN\n \n// Inferior or equal of the value\n\n\n\n// Possible value of behavior on the onSort handler :\n\n\nconst\n \n{\n \nSORT_BEHAVIOR\n \n}\n \n=\n \nQUERY\n;\n\n\nSORT_BEHAVIOR\n.\nASCENDING\n \n// Ascending order\n\n\nSORT_BEHAVIOR\n.\nDESCENDING\n \n// Descending order\n\n\n\n\nupdateBuilder\n\n\nquery.updateBuilder is used to handle the update kind of query. Like the queryBuilder\nyou need to give him handler to build your query\n\nquery\n.\nupdateBuilder\n({\n\n  \n// Apply an update operation\n\n  \n// Key is the targeted key\n\n  \n// Operator is the operation to make\n\n  \n// Value is the value to apply\n\n  \nonOperator\n:\n \n({\n \nkey\n,\n \noperator\n,\n \nvalue\n,\n \n})\n \n=\n \n{},\n\n\n})\n\n\n\n\nYou can use the OPERATIONS constant to compare with the operator\n\nconst\n \n{\n \nOPERATIONS\n \n}\n \n=\n \nrequire\n(\nilorm-constants\n).\nQUERY\n;\n\n\n\n// Set the value associated with the key :\n\n\nOPERATIONS\n.\nSET\n\n\n\n// Increment the value associated with the key (could be a negative number to decrement) :\n\n\nOPERATIONS\n.\nADD\n\n\n\n\nDatabase operation to implement\n\n\nThis part list all database related method to implement in your Connector.\nAll operations are async :\n\n\n\n\n\n\ncount(query) : Return the number of element associated with the specified query.\n\n\n\n\n\n\ncreate(item|arrayOfItem) : The handler need to create all item into the database.\n\n\n\n\n\n\nfind(query) : Return an array of all element linked with the specified query.\n\n\n\n\n\n\nfindOne(query) : Return the first element linked with the specified query.\n\n\n\n\n\n\nremove(query) : Remove all element which match the query\n\n\n\n\n\n\nremoveOne(query) : RemoveOne element which match the query\n\n\n\n\n\n\nstream(query) : Return a stream which stream all element associated with the query.\n\n\n\n\n\n\nupdate(query) : Update all element which match the query\n\n\n\n\n\n\nupdateOne(query) : Update the first element which match the query\n\n\n\n\n\n\nConnector factory\n\n\nOn your connector, you need to implement to more method :\n\n\n\n\n\n\nmodelFactory : Will return a Model class linked with your connector.\n\n\n\n\n\n\nqueryFactory : Will return a Query class linked with your connector.\n\n\n\n\n\n\nBoth method take in parameter a base Class used as parent of the future class.\n\n\nmodelFactory\n\n\nWith ilorm, every Model are inheritance of two class minimum :\n\n\n\n\n\n\nBaseModel : The lowest level, this class is defined in ilorm core.\n\n\n\n\n\n\nFactoryModel : Overload BaseModel to specify name, schema, connector, plugin, linked with \nthe current model. This Class is generated to every model when calling ilorm.newModel. This\nclass is defined in ilorm core too. This class is given in parameter of ModelFactory\n\n\n\n\n\n\nDatabaseModel : The last mandatory level, it's the result the modelFactory, you can add\nevery kind of specific behavior of your database here.\n\n\n\n\n\n\nPlugin could overload BaseModel (you can have Model inheritance between BaseModel and\nFactoryModel).\n\n\n\n\nThe final user could overload your DatabaseModel.\n\n\n\n\nThe signature of modelFactory is ;\nDatabaseModel result = Connector.modelFactory({ name, schema, ParentModel });\n\n\n\n\n\n\nname : The name of the model, given by the developer who using your connector.\n\n\n\n\n\n\nschema : The schema binded with the current model.\n\n\n\n\n\n\nParentModel : The FactoryModel (Your Model need to inherit from this parameter).\n\n\n\n\n\n\nqueryFactory\n\n\nQuery are similar to Model. Every query are composed by a BaseQuery (defined in core),\noverloaded by InternalQuery to specify the binded model. And your connector Query is the last\npart of the system. Plugin could overload BaseQuery.\n\n\nThe signature of the queryFactory is :\nDatabaseQuery result = Connector.queryFactory({ schema, ParentQuery, });\n\n\n\n\n\n\nschema : The schema binded with your query\n\n\n\n\n\n\nParentQuery : The ParentQuery (your Query need to inherit from this parameter)", 
            "title": "Create connector"
        }, 
        {
            "location": "/advanced/create_connector/#create-a-connector", 
            "text": "", 
            "title": "Create a connector"
        }, 
        {
            "location": "/advanced/create_connector/#the-connector-class", 
            "text": "", 
            "title": "The connector class"
        }, 
        {
            "location": "/advanced/create_connector/#basics", 
            "text": "To create a connector, you need to implement a class Connector.  The class Connector is always linked with a database\nThe instance of the class is linked with a table, a collection or a subset of data.  Example :    On a SQL database    The class is linked with the full database    An instance of the class is linked with a table      On a MongoDB database    The class linked with the full database    An instance of the class is linked with a collection", 
            "title": "Basics"
        }, 
        {
            "location": "/advanced/create_connector/#mandatory-operation", 
            "text": "The class need to implement mandatory operation to be fully functional.\nThe operations are divided into :    Database related : Update, Find, Create, Remove data    Connector factory : The connector instantiate his own Query class or Model class to overwrite\nbasic behavior.", 
            "title": "Mandatory operation"
        }, 
        {
            "location": "/advanced/create_connector/#database-related", 
            "text": "", 
            "title": "Database related"
        }, 
        {
            "location": "/advanced/create_connector/#ilorm-query", 
            "text": "The majority of database related operation receive a Query instance as parameter.\nYou need to use this query instance to create the same query in the database language\nto do it. The query have some useful method : queryBuilder and updateBuilder.", 
            "title": "Ilorm query"
        }, 
        {
            "location": "/advanced/create_connector/#querybuilder", 
            "text": "query.queryBuilder is use to restrict your query. You will put as parameter of queryBuilder\na set of handler. Each handler should be called back (in function of the query). query . queryBuilder ({ \n   // On option will be called if skip   limit was put : \n   onOption :   ( skip ,   limit )   =   {}, \n\n   // If an or operator is used on the query, this handler will be called \n   // The parameter is multiple query instance (each or branch) \n   onOr :   arrayOfQuery   =   {}, \n\n   // If one or more field are select, this handler will be called \n   // You need to restrict result only to the specified field \n   onSelect :   ({   field ,   })   =   {}, \n\n   // Called (in order), to set the order of the result. \n   // Key is the target sorting key \n   // behavior precise if it s ascending or descending sorting \n   onSort :   ({   key ,   behavior ,   })   =   {}, \n\n   // Called per each query operation \n   // Key is the target key \n   // Operation is EQUAL, NOT_EQUAL... \n   // Value is the value applied to the operation \n   onOperator :   ({   key ,   operation ,   value ,   })   =   {}  });  \nBehavior and operation are equal to specific constants. The constants can be found in ilorm-constants  in the QUERY constants : const   {   QUERY ,   }   =   require ( ilorm-constants );  // Possible value of operation on the onOperator handler :  const   {   OPERATIONS   }   =   QUERY ;  OPERATION . IS   // equal (===)  OPERATION . IS_NOT   // Not equal (!==)  OPERATION . IS_IN   // The value is in the specified array of possibility  OPERATION . IS_NOT_IN   // The value is not in the specified array of possibility  OPERATION . GREATHER_THAN   // Superior of the value  OPERATION . LOWER_THAN   // Inferior of the value  OPERATION_GREATHER_OR_EQUAL_THAN   // Superior or equal of the value  OPERATION . LOWER_OR_EQUAL_THAN   // Inferior or equal of the value  // Possible value of behavior on the onSort handler :  const   {   SORT_BEHAVIOR   }   =   QUERY ;  SORT_BEHAVIOR . ASCENDING   // Ascending order  SORT_BEHAVIOR . DESCENDING   // Descending order", 
            "title": "queryBuilder"
        }, 
        {
            "location": "/advanced/create_connector/#updatebuilder", 
            "text": "query.updateBuilder is used to handle the update kind of query. Like the queryBuilder\nyou need to give him handler to build your query query . updateBuilder ({ \n   // Apply an update operation \n   // Key is the targeted key \n   // Operator is the operation to make \n   // Value is the value to apply \n   onOperator :   ({   key ,   operator ,   value ,   })   =   {},  })   You can use the OPERATIONS constant to compare with the operator const   {   OPERATIONS   }   =   require ( ilorm-constants ). QUERY ;  // Set the value associated with the key :  OPERATIONS . SET  // Increment the value associated with the key (could be a negative number to decrement) :  OPERATIONS . ADD", 
            "title": "updateBuilder"
        }, 
        {
            "location": "/advanced/create_connector/#database-operation-to-implement", 
            "text": "This part list all database related method to implement in your Connector.\nAll operations are async :    count(query) : Return the number of element associated with the specified query.    create(item|arrayOfItem) : The handler need to create all item into the database.    find(query) : Return an array of all element linked with the specified query.    findOne(query) : Return the first element linked with the specified query.    remove(query) : Remove all element which match the query    removeOne(query) : RemoveOne element which match the query    stream(query) : Return a stream which stream all element associated with the query.    update(query) : Update all element which match the query    updateOne(query) : Update the first element which match the query", 
            "title": "Database operation to implement"
        }, 
        {
            "location": "/advanced/create_connector/#connector-factory", 
            "text": "On your connector, you need to implement to more method :    modelFactory : Will return a Model class linked with your connector.    queryFactory : Will return a Query class linked with your connector.    Both method take in parameter a base Class used as parent of the future class.", 
            "title": "Connector factory"
        }, 
        {
            "location": "/advanced/create_connector/#modelfactory", 
            "text": "With ilorm, every Model are inheritance of two class minimum :    BaseModel : The lowest level, this class is defined in ilorm core.    FactoryModel : Overload BaseModel to specify name, schema, connector, plugin, linked with \nthe current model. This Class is generated to every model when calling ilorm.newModel. This\nclass is defined in ilorm core too. This class is given in parameter of ModelFactory    DatabaseModel : The last mandatory level, it's the result the modelFactory, you can add\nevery kind of specific behavior of your database here.    Plugin could overload BaseModel (you can have Model inheritance between BaseModel and\nFactoryModel).   The final user could overload your DatabaseModel.   The signature of modelFactory is ;\nDatabaseModel result = Connector.modelFactory({ name, schema, ParentModel });    name : The name of the model, given by the developer who using your connector.    schema : The schema binded with the current model.    ParentModel : The FactoryModel (Your Model need to inherit from this parameter).", 
            "title": "modelFactory"
        }, 
        {
            "location": "/advanced/create_connector/#queryfactory", 
            "text": "Query are similar to Model. Every query are composed by a BaseQuery (defined in core),\noverloaded by InternalQuery to specify the binded model. And your connector Query is the last\npart of the system. Plugin could overload BaseQuery.  The signature of the queryFactory is :\nDatabaseQuery result = Connector.queryFactory({ schema, ParentQuery, });    schema : The schema binded with your query    ParentQuery : The ParentQuery (your Query need to inherit from this parameter)", 
            "title": "queryFactory"
        }, 
        {
            "location": "/connectors/mongodb/", 
            "text": "ilorm-connector-mongo\n\n\nThe MongoDB connector is the Connector to use mongoDB as storage for your ilorm model.\n\n\nFeatures\n\n\n\n\nAdd MongoDB as connector.\n\n\nAdd specifics MongoDB SchemaFields : Array, Map, Object and ObjectId.\n\n\nAdd specifics MongoDB query operator : push (on Array only).\n\n\nAdd Model.aggregate to build aggregation pipeline.\n\n\n\n\nHow it works\n\n\nTo use this connector :\n\n\n\n\n\n\nfirst declare it in your project :\n\nconst\n \nilorm\n \n=\n \nrequire\n(\nilorm\n);\n\n\nconst\n \nilormMongo\n \n=\n \nrequire\n(\nilorm-connector-mongodb\n);\n\n\n\nilorm\n.\nuse\n(\nilormMongo\n);\n\n\n\n\n\n\n\n\nSecond, you need to create a MongoConnector. To do that, you need to make a connection\nbetween your database and your project. You can create it with a basic mongo client :\n\nconst\n \nilormMongo\n \n=\n \nrequire\n(\nilorm-connector-mongodb\n);\n\n\nconst\n \n{\n \nMongoClient\n,\n \n}\n \n=\n \nrequire\n(\nmongodb\n);\n\n\nconst\n \nDB_URL\n \n=\n \nmongodb://localhost:27017/ilorm\n;\n\n\n\nconst\n \nmongoClient\n \n=\n \nawait\n \nMongoClient\n.\nconnect\n(\nDB_URL\n);\n\n\nconst\n \ndatabase\n \n=\n \nawait\n \nmongoClient\n.\ndb\n(\nilorm\n);\n\n\n\nconst\n \nMongoConnector\n \n=\n \nilormMongo\n.\nfromClient\n(\ndatabase\n);\n\n\n\n\n\n\n\n\nFinally you need to choose the collection used to store your model :\n\nconst\n \nmodelFactoryParams\n \n=\n \n{\n\n  \nname\n:\n \nusers\n,\n\n  \nschema\n:\n \nuserSchema\n,\n\n  \nconnector\n:\n \nnew\n \nMongoConnector\n({\n\n    \ncollectionName\n:\n \nusers\n,\n\n  \n}),\n\n\n};\n\n\n\nconst\n \nUserModel\n \n=\n \nnewModel\n(\nmodelFactoryParams\n);\n\n\n\n\n\n\n\n\nConnector\n\n\n(constructor) Connector\n\n\nModel\n\n\nQuery\n\n\nSchema\n\n\nSchemaField\n\n\nArray\n\n\nArray is used to define embed array in your Schema. You could define behavior of the \nchild element.\n\n// To store users in a array ;\n\n\nnew\n \nSchema\n({\n\n  \nusers\n:\n \nSchema\n.\narray\n({\n\n    \nfirstName\n:\n \nSchema\n.\nString\n(),\n\n    \nlastName\n:\n \nSchema\n.\nstring\n()\n\n  \n}),\n\n\n});\n\n\n\n\nMap\n\n\nMap is used to define Map in your Schema. A map is a key: value association.\nYou can define behavior of the child element (the value of the array). And the format\nof your key.\n\n\nObject\n\n\nObject is used to define embed Object in your Schema. You could define behavior of the \nchild element. \n\n\nObjectId\n\n\nObjectId is the ID system used by MongoDB.", 
            "title": "MongoDB"
        }, 
        {
            "location": "/connectors/mongodb/#ilorm-connector-mongo", 
            "text": "The MongoDB connector is the Connector to use mongoDB as storage for your ilorm model.", 
            "title": "ilorm-connector-mongo"
        }, 
        {
            "location": "/connectors/mongodb/#features", 
            "text": "Add MongoDB as connector.  Add specifics MongoDB SchemaFields : Array, Map, Object and ObjectId.  Add specifics MongoDB query operator : push (on Array only).  Add Model.aggregate to build aggregation pipeline.", 
            "title": "Features"
        }, 
        {
            "location": "/connectors/mongodb/#how-it-works", 
            "text": "To use this connector :    first declare it in your project : const   ilorm   =   require ( ilorm );  const   ilormMongo   =   require ( ilorm-connector-mongodb );  ilorm . use ( ilormMongo );     Second, you need to create a MongoConnector. To do that, you need to make a connection\nbetween your database and your project. You can create it with a basic mongo client : const   ilormMongo   =   require ( ilorm-connector-mongodb );  const   {   MongoClient ,   }   =   require ( mongodb );  const   DB_URL   =   mongodb://localhost:27017/ilorm ;  const   mongoClient   =   await   MongoClient . connect ( DB_URL );  const   database   =   await   mongoClient . db ( ilorm );  const   MongoConnector   =   ilormMongo . fromClient ( database );     Finally you need to choose the collection used to store your model : const   modelFactoryParams   =   { \n   name :   users , \n   schema :   userSchema , \n   connector :   new   MongoConnector ({ \n     collectionName :   users , \n   }),  };  const   UserModel   =   newModel ( modelFactoryParams );", 
            "title": "How it works"
        }, 
        {
            "location": "/connectors/mongodb/#connector", 
            "text": "", 
            "title": "Connector"
        }, 
        {
            "location": "/connectors/mongodb/#constructor-connector", 
            "text": "", 
            "title": "(constructor) Connector"
        }, 
        {
            "location": "/connectors/mongodb/#model", 
            "text": "", 
            "title": "Model"
        }, 
        {
            "location": "/connectors/mongodb/#query", 
            "text": "", 
            "title": "Query"
        }, 
        {
            "location": "/connectors/mongodb/#schema", 
            "text": "", 
            "title": "Schema"
        }, 
        {
            "location": "/connectors/mongodb/#schemafield", 
            "text": "", 
            "title": "SchemaField"
        }, 
        {
            "location": "/connectors/mongodb/#array", 
            "text": "Array is used to define embed array in your Schema. You could define behavior of the \nchild element. // To store users in a array ;  new   Schema ({ \n   users :   Schema . array ({ \n     firstName :   Schema . String (), \n     lastName :   Schema . string () \n   }),  });", 
            "title": "Array"
        }, 
        {
            "location": "/connectors/mongodb/#map", 
            "text": "Map is used to define Map in your Schema. A map is a key: value association.\nYou can define behavior of the child element (the value of the array). And the format\nof your key.", 
            "title": "Map"
        }, 
        {
            "location": "/connectors/mongodb/#object", 
            "text": "Object is used to define embed Object in your Schema. You could define behavior of the \nchild element.", 
            "title": "Object"
        }, 
        {
            "location": "/connectors/mongodb/#objectid", 
            "text": "ObjectId is the ID system used by MongoDB.", 
            "title": "ObjectId"
        }
    ]
}